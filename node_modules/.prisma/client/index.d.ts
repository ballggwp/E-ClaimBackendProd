
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Claim
 * 
 */
export type Claim = $Result.DefaultSelection<Prisma.$ClaimPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model CPMForm
 * 
 */
export type CPMForm = $Result.DefaultSelection<Prisma.$CPMFormPayload>
/**
 * Model Fppa04Base
 * 
 */
export type Fppa04Base = $Result.DefaultSelection<Prisma.$Fppa04BasePayload>
/**
 * Model Fppa04CPM
 * 
 */
export type Fppa04CPM = $Result.DefaultSelection<Prisma.$Fppa04CPMPayload>
/**
 * Model Fppa04ItemCPM
 * 
 */
export type Fppa04ItemCPM = $Result.DefaultSelection<Prisma.$Fppa04ItemCPMPayload>
/**
 * Model Fppa04AdjustmentCPM
 * 
 */
export type Fppa04AdjustmentCPM = $Result.DefaultSelection<Prisma.$Fppa04AdjustmentCPMPayload>
/**
 * Model ClaimHistory
 * 
 */
export type ClaimHistory = $Result.DefaultSelection<Prisma.$ClaimHistoryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ClaimStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVER_REVIEW: 'PENDING_APPROVER_REVIEW',
  PENDING_INSURER_REVIEW: 'PENDING_INSURER_REVIEW',
  AWAITING_EVIDENCE: 'AWAITING_EVIDENCE',
  PENDING_INSURER_FORM: 'PENDING_INSURER_FORM',
  PENDING_MANAGER_REVIEW: 'PENDING_MANAGER_REVIEW',
  PENDING_USER_CONFIRM: 'PENDING_USER_CONFIRM',
  AWAITING_SIGNATURES: 'AWAITING_SIGNATURES',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED'
};

export type ClaimStatus = (typeof ClaimStatus)[keyof typeof ClaimStatus]


export const AttachmentType: {
  DAMAGE_IMAGE: 'DAMAGE_IMAGE',
  ESTIMATE_DOC: 'ESTIMATE_DOC',
  OTHER_DOCUMENT: 'OTHER_DOCUMENT',
  USER_CONFIRM_DOC: 'USER_CONFIRM_DOC',
  INSURANCE_DOC: 'INSURANCE_DOC'
};

export type AttachmentType = (typeof AttachmentType)[keyof typeof AttachmentType]


export const Role: {
  USER: 'USER',
  MANAGER: 'MANAGER',
  INSURANCE: 'INSURANCE'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type ClaimStatus = $Enums.ClaimStatus

export const ClaimStatus: typeof $Enums.ClaimStatus

export type AttachmentType = $Enums.AttachmentType

export const AttachmentType: typeof $Enums.AttachmentType

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cPMForm`: Exposes CRUD operations for the **CPMForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CPMForms
    * const cPMForms = await prisma.cPMForm.findMany()
    * ```
    */
  get cPMForm(): Prisma.CPMFormDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fppa04Base`: Exposes CRUD operations for the **Fppa04Base** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fppa04Bases
    * const fppa04Bases = await prisma.fppa04Base.findMany()
    * ```
    */
  get fppa04Base(): Prisma.Fppa04BaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fppa04CPM`: Exposes CRUD operations for the **Fppa04CPM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fppa04CPMS
    * const fppa04CPMS = await prisma.fppa04CPM.findMany()
    * ```
    */
  get fppa04CPM(): Prisma.Fppa04CPMDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fppa04ItemCPM`: Exposes CRUD operations for the **Fppa04ItemCPM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fppa04ItemCPMS
    * const fppa04ItemCPMS = await prisma.fppa04ItemCPM.findMany()
    * ```
    */
  get fppa04ItemCPM(): Prisma.Fppa04ItemCPMDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fppa04AdjustmentCPM`: Exposes CRUD operations for the **Fppa04AdjustmentCPM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fppa04AdjustmentCPMS
    * const fppa04AdjustmentCPMS = await prisma.fppa04AdjustmentCPM.findMany()
    * ```
    */
  get fppa04AdjustmentCPM(): Prisma.Fppa04AdjustmentCPMDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.claimHistory`: Exposes CRUD operations for the **ClaimHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClaimHistories
    * const claimHistories = await prisma.claimHistory.findMany()
    * ```
    */
  get claimHistory(): Prisma.ClaimHistoryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Claim: 'Claim',
    Attachment: 'Attachment',
    CPMForm: 'CPMForm',
    Fppa04Base: 'Fppa04Base',
    Fppa04CPM: 'Fppa04CPM',
    Fppa04ItemCPM: 'Fppa04ItemCPM',
    Fppa04AdjustmentCPM: 'Fppa04AdjustmentCPM',
    ClaimHistory: 'ClaimHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "claim" | "attachment" | "cPMForm" | "fppa04Base" | "fppa04CPM" | "fppa04ItemCPM" | "fppa04AdjustmentCPM" | "claimHistory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: Prisma.$ClaimPayload<ExtArgs>
        fields: Prisma.ClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      CPMForm: {
        payload: Prisma.$CPMFormPayload<ExtArgs>
        fields: Prisma.CPMFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CPMFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CPMFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>
          }
          findFirst: {
            args: Prisma.CPMFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CPMFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>
          }
          findMany: {
            args: Prisma.CPMFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>[]
          }
          create: {
            args: Prisma.CPMFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>
          }
          createMany: {
            args: Prisma.CPMFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CPMFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>[]
          }
          delete: {
            args: Prisma.CPMFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>
          }
          update: {
            args: Prisma.CPMFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>
          }
          deleteMany: {
            args: Prisma.CPMFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CPMFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CPMFormUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>[]
          }
          upsert: {
            args: Prisma.CPMFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CPMFormPayload>
          }
          aggregate: {
            args: Prisma.CPMFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCPMForm>
          }
          groupBy: {
            args: Prisma.CPMFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<CPMFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.CPMFormCountArgs<ExtArgs>
            result: $Utils.Optional<CPMFormCountAggregateOutputType> | number
          }
        }
      }
      Fppa04Base: {
        payload: Prisma.$Fppa04BasePayload<ExtArgs>
        fields: Prisma.Fppa04BaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Fppa04BaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Fppa04BaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>
          }
          findFirst: {
            args: Prisma.Fppa04BaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Fppa04BaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>
          }
          findMany: {
            args: Prisma.Fppa04BaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>[]
          }
          create: {
            args: Prisma.Fppa04BaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>
          }
          createMany: {
            args: Prisma.Fppa04BaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Fppa04BaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>[]
          }
          delete: {
            args: Prisma.Fppa04BaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>
          }
          update: {
            args: Prisma.Fppa04BaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>
          }
          deleteMany: {
            args: Prisma.Fppa04BaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Fppa04BaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Fppa04BaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>[]
          }
          upsert: {
            args: Prisma.Fppa04BaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04BasePayload>
          }
          aggregate: {
            args: Prisma.Fppa04BaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFppa04Base>
          }
          groupBy: {
            args: Prisma.Fppa04BaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<Fppa04BaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.Fppa04BaseCountArgs<ExtArgs>
            result: $Utils.Optional<Fppa04BaseCountAggregateOutputType> | number
          }
        }
      }
      Fppa04CPM: {
        payload: Prisma.$Fppa04CPMPayload<ExtArgs>
        fields: Prisma.Fppa04CPMFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Fppa04CPMFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Fppa04CPMFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>
          }
          findFirst: {
            args: Prisma.Fppa04CPMFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Fppa04CPMFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>
          }
          findMany: {
            args: Prisma.Fppa04CPMFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>[]
          }
          create: {
            args: Prisma.Fppa04CPMCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>
          }
          createMany: {
            args: Prisma.Fppa04CPMCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Fppa04CPMCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>[]
          }
          delete: {
            args: Prisma.Fppa04CPMDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>
          }
          update: {
            args: Prisma.Fppa04CPMUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>
          }
          deleteMany: {
            args: Prisma.Fppa04CPMDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Fppa04CPMUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Fppa04CPMUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>[]
          }
          upsert: {
            args: Prisma.Fppa04CPMUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04CPMPayload>
          }
          aggregate: {
            args: Prisma.Fppa04CPMAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFppa04CPM>
          }
          groupBy: {
            args: Prisma.Fppa04CPMGroupByArgs<ExtArgs>
            result: $Utils.Optional<Fppa04CPMGroupByOutputType>[]
          }
          count: {
            args: Prisma.Fppa04CPMCountArgs<ExtArgs>
            result: $Utils.Optional<Fppa04CPMCountAggregateOutputType> | number
          }
        }
      }
      Fppa04ItemCPM: {
        payload: Prisma.$Fppa04ItemCPMPayload<ExtArgs>
        fields: Prisma.Fppa04ItemCPMFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Fppa04ItemCPMFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Fppa04ItemCPMFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>
          }
          findFirst: {
            args: Prisma.Fppa04ItemCPMFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Fppa04ItemCPMFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>
          }
          findMany: {
            args: Prisma.Fppa04ItemCPMFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>[]
          }
          create: {
            args: Prisma.Fppa04ItemCPMCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>
          }
          createMany: {
            args: Prisma.Fppa04ItemCPMCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Fppa04ItemCPMCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>[]
          }
          delete: {
            args: Prisma.Fppa04ItemCPMDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>
          }
          update: {
            args: Prisma.Fppa04ItemCPMUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>
          }
          deleteMany: {
            args: Prisma.Fppa04ItemCPMDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Fppa04ItemCPMUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Fppa04ItemCPMUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>[]
          }
          upsert: {
            args: Prisma.Fppa04ItemCPMUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04ItemCPMPayload>
          }
          aggregate: {
            args: Prisma.Fppa04ItemCPMAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFppa04ItemCPM>
          }
          groupBy: {
            args: Prisma.Fppa04ItemCPMGroupByArgs<ExtArgs>
            result: $Utils.Optional<Fppa04ItemCPMGroupByOutputType>[]
          }
          count: {
            args: Prisma.Fppa04ItemCPMCountArgs<ExtArgs>
            result: $Utils.Optional<Fppa04ItemCPMCountAggregateOutputType> | number
          }
        }
      }
      Fppa04AdjustmentCPM: {
        payload: Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>
        fields: Prisma.Fppa04AdjustmentCPMFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Fppa04AdjustmentCPMFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Fppa04AdjustmentCPMFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>
          }
          findFirst: {
            args: Prisma.Fppa04AdjustmentCPMFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Fppa04AdjustmentCPMFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>
          }
          findMany: {
            args: Prisma.Fppa04AdjustmentCPMFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>[]
          }
          create: {
            args: Prisma.Fppa04AdjustmentCPMCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>
          }
          createMany: {
            args: Prisma.Fppa04AdjustmentCPMCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Fppa04AdjustmentCPMCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>[]
          }
          delete: {
            args: Prisma.Fppa04AdjustmentCPMDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>
          }
          update: {
            args: Prisma.Fppa04AdjustmentCPMUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>
          }
          deleteMany: {
            args: Prisma.Fppa04AdjustmentCPMDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Fppa04AdjustmentCPMUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Fppa04AdjustmentCPMUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>[]
          }
          upsert: {
            args: Prisma.Fppa04AdjustmentCPMUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Fppa04AdjustmentCPMPayload>
          }
          aggregate: {
            args: Prisma.Fppa04AdjustmentCPMAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFppa04AdjustmentCPM>
          }
          groupBy: {
            args: Prisma.Fppa04AdjustmentCPMGroupByArgs<ExtArgs>
            result: $Utils.Optional<Fppa04AdjustmentCPMGroupByOutputType>[]
          }
          count: {
            args: Prisma.Fppa04AdjustmentCPMCountArgs<ExtArgs>
            result: $Utils.Optional<Fppa04AdjustmentCPMCountAggregateOutputType> | number
          }
        }
      }
      ClaimHistory: {
        payload: Prisma.$ClaimHistoryPayload<ExtArgs>
        fields: Prisma.ClaimHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>
          }
          findFirst: {
            args: Prisma.ClaimHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>
          }
          findMany: {
            args: Prisma.ClaimHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>[]
          }
          create: {
            args: Prisma.ClaimHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>
          }
          createMany: {
            args: Prisma.ClaimHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClaimHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>[]
          }
          delete: {
            args: Prisma.ClaimHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>
          }
          update: {
            args: Prisma.ClaimHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ClaimHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClaimHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ClaimHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimHistoryPayload>
          }
          aggregate: {
            args: Prisma.ClaimHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaimHistory>
          }
          groupBy: {
            args: Prisma.ClaimHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimHistoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    claim?: ClaimOmit
    attachment?: AttachmentOmit
    cPMForm?: CPMFormOmit
    fppa04Base?: Fppa04BaseOmit
    fppa04CPM?: Fppa04CPMOmit
    fppa04ItemCPM?: Fppa04ItemCPMOmit
    fppa04AdjustmentCPM?: Fppa04AdjustmentCPMOmit
    claimHistory?: ClaimHistoryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    claimsCreated: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claimsCreated?: boolean | UserCountOutputTypeCountClaimsCreatedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaimsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }


  /**
   * Count Type ClaimCountOutputType
   */

  export type ClaimCountOutputType = {
    attachments: number
    history: number
  }

  export type ClaimCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | ClaimCountOutputTypeCountAttachmentsArgs
    history?: boolean | ClaimCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimCountOutputType
     */
    select?: ClaimCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimHistoryWhereInput
  }


  /**
   * Count Type Fppa04CPMCountOutputType
   */

  export type Fppa04CPMCountOutputType = {
    items: number
    adjustments: number
  }

  export type Fppa04CPMCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Fppa04CPMCountOutputTypeCountItemsArgs
    adjustments?: boolean | Fppa04CPMCountOutputTypeCountAdjustmentsArgs
  }

  // Custom InputTypes
  /**
   * Fppa04CPMCountOutputType without action
   */
  export type Fppa04CPMCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPMCountOutputType
     */
    select?: Fppa04CPMCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Fppa04CPMCountOutputType without action
   */
  export type Fppa04CPMCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Fppa04ItemCPMWhereInput
  }

  /**
   * Fppa04CPMCountOutputType without action
   */
  export type Fppa04CPMCountOutputTypeCountAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Fppa04AdjustmentCPMWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    employeeNumber: string | null
    name: string | null
    department: string | null
    role: $Enums.Role | null
    position: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    employeeNumber: string | null
    name: string | null
    department: string | null
    role: $Enums.Role | null
    position: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    employeeNumber: number
    name: number
    department: number
    role: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    employeeNumber?: true
    name?: true
    department?: true
    role?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    employeeNumber?: true
    name?: true
    department?: true
    role?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    employeeNumber?: true
    name?: true
    department?: true
    role?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    employeeNumber: string
    name: string
    department: string | null
    role: $Enums.Role
    position: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    employeeNumber?: boolean
    name?: boolean
    department?: boolean
    role?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claimsCreated?: boolean | User$claimsCreatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    employeeNumber?: boolean
    name?: boolean
    department?: boolean
    role?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    employeeNumber?: boolean
    name?: boolean
    department?: boolean
    role?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    employeeNumber?: boolean
    name?: boolean
    department?: boolean
    role?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "employeeNumber" | "name" | "department" | "role" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claimsCreated?: boolean | User$claimsCreatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      claimsCreated: Prisma.$ClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      employeeNumber: string
      name: string
      department: string | null
      role: $Enums.Role
      position: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claimsCreated<T extends User$claimsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$claimsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly employeeNumber: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly position: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.claimsCreated
   */
  export type User$claimsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Claim
   */

  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    docNum: string | null
    createdByName: string | null
    approverName: string | null
    approverPosition: string | null
    approverDepartment: string | null
    createdById: string | null
    approverEmail: string | null
    approverId: string | null
    signerId: string | null
    signerEmail: string | null
    signerName: string | null
    signerPosition: string | null
    status: $Enums.ClaimStatus | null
    categoryMain: string | null
    categorySub: string | null
    submittedAt: Date | null
    insurerComment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    docNum: string | null
    createdByName: string | null
    approverName: string | null
    approverPosition: string | null
    approverDepartment: string | null
    createdById: string | null
    approverEmail: string | null
    approverId: string | null
    signerId: string | null
    signerEmail: string | null
    signerName: string | null
    signerPosition: string | null
    status: $Enums.ClaimStatus | null
    categoryMain: string | null
    categorySub: string | null
    submittedAt: Date | null
    insurerComment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    docNum: number
    createdByName: number
    approverName: number
    approverPosition: number
    approverDepartment: number
    createdById: number
    approverEmail: number
    approverId: number
    signerId: number
    signerEmail: number
    signerName: number
    signerPosition: number
    status: number
    categoryMain: number
    categorySub: number
    submittedAt: number
    insurerComment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClaimMinAggregateInputType = {
    id?: true
    docNum?: true
    createdByName?: true
    approverName?: true
    approverPosition?: true
    approverDepartment?: true
    createdById?: true
    approverEmail?: true
    approverId?: true
    signerId?: true
    signerEmail?: true
    signerName?: true
    signerPosition?: true
    status?: true
    categoryMain?: true
    categorySub?: true
    submittedAt?: true
    insurerComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    docNum?: true
    createdByName?: true
    approverName?: true
    approverPosition?: true
    approverDepartment?: true
    createdById?: true
    approverEmail?: true
    approverId?: true
    signerId?: true
    signerEmail?: true
    signerName?: true
    signerPosition?: true
    status?: true
    categoryMain?: true
    categorySub?: true
    submittedAt?: true
    insurerComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    docNum?: true
    createdByName?: true
    approverName?: true
    approverPosition?: true
    approverDepartment?: true
    createdById?: true
    approverEmail?: true
    approverId?: true
    signerId?: true
    signerEmail?: true
    signerName?: true
    signerPosition?: true
    status?: true
    categoryMain?: true
    categorySub?: true
    submittedAt?: true
    insurerComment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithAggregationInput | ClaimOrderByWithAggregationInput[]
    by: ClaimScalarFieldEnum[] | ClaimScalarFieldEnum
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }

  export type ClaimGroupByOutputType = {
    id: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    createdById: string
    approverEmail: string
    approverId: string
    signerId: string | null
    signerEmail: string | null
    signerName: string | null
    signerPosition: string | null
    status: $Enums.ClaimStatus
    categoryMain: string | null
    categorySub: string | null
    submittedAt: Date | null
    insurerComment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClaimCountAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    docNum?: boolean
    createdByName?: boolean
    approverName?: boolean
    approverPosition?: boolean
    approverDepartment?: boolean
    createdById?: boolean
    approverEmail?: boolean
    approverId?: boolean
    signerId?: boolean
    signerEmail?: boolean
    signerName?: boolean
    signerPosition?: boolean
    status?: boolean
    categoryMain?: boolean
    categorySub?: boolean
    submittedAt?: boolean
    insurerComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Claim$attachmentsArgs<ExtArgs>
    cpmForm?: boolean | Claim$cpmFormArgs<ExtArgs>
    fppa04Base?: boolean | Claim$fppa04BaseArgs<ExtArgs>
    history?: boolean | Claim$historyArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    docNum?: boolean
    createdByName?: boolean
    approverName?: boolean
    approverPosition?: boolean
    approverDepartment?: boolean
    createdById?: boolean
    approverEmail?: boolean
    approverId?: boolean
    signerId?: boolean
    signerEmail?: boolean
    signerName?: boolean
    signerPosition?: boolean
    status?: boolean
    categoryMain?: boolean
    categorySub?: boolean
    submittedAt?: boolean
    insurerComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    docNum?: boolean
    createdByName?: boolean
    approverName?: boolean
    approverPosition?: boolean
    approverDepartment?: boolean
    createdById?: boolean
    approverEmail?: boolean
    approverId?: boolean
    signerId?: boolean
    signerEmail?: boolean
    signerName?: boolean
    signerPosition?: boolean
    status?: boolean
    categoryMain?: boolean
    categorySub?: boolean
    submittedAt?: boolean
    insurerComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    docNum?: boolean
    createdByName?: boolean
    approverName?: boolean
    approverPosition?: boolean
    approverDepartment?: boolean
    createdById?: boolean
    approverEmail?: boolean
    approverId?: boolean
    signerId?: boolean
    signerEmail?: boolean
    signerName?: boolean
    signerPosition?: boolean
    status?: boolean
    categoryMain?: boolean
    categorySub?: boolean
    submittedAt?: boolean
    insurerComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "docNum" | "createdByName" | "approverName" | "approverPosition" | "approverDepartment" | "createdById" | "approverEmail" | "approverId" | "signerId" | "signerEmail" | "signerName" | "signerPosition" | "status" | "categoryMain" | "categorySub" | "submittedAt" | "insurerComment" | "createdAt" | "updatedAt", ExtArgs["result"]["claim"]>
  export type ClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Claim$attachmentsArgs<ExtArgs>
    cpmForm?: boolean | Claim$cpmFormArgs<ExtArgs>
    fppa04Base?: boolean | Claim$fppa04BaseArgs<ExtArgs>
    history?: boolean | Claim$historyArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Claim"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      cpmForm: Prisma.$CPMFormPayload<ExtArgs> | null
      fppa04Base: Prisma.$Fppa04BasePayload<ExtArgs> | null
      history: Prisma.$ClaimHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      docNum: string
      createdByName: string
      approverName: string
      approverPosition: string
      approverDepartment: string
      createdById: string
      approverEmail: string
      approverId: string
      signerId: string | null
      signerEmail: string | null
      signerName: string | null
      signerPosition: string | null
      status: $Enums.ClaimStatus
      categoryMain: string | null
      categorySub: string | null
      submittedAt: Date | null
      insurerComment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["claim"]>
    composites: {}
  }

  type ClaimGetPayload<S extends boolean | null | undefined | ClaimDefaultArgs> = $Result.GetResult<Prisma.$ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimFindUniqueArgs>(args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Claim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimFindFirstArgs>(args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Claim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimFindManyArgs>(args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
     */
    create<T extends ClaimCreateArgs>(args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Claims.
     * @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimCreateManyArgs>(args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Claims and returns the data saved in the database.
     * @param {ClaimCreateManyAndReturnArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, ClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
     */
    delete<T extends ClaimDeleteArgs>(args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimUpdateArgs>(args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimDeleteManyArgs>(args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimUpdateManyArgs>(args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims and returns the data updated in the database.
     * @param {ClaimUpdateManyAndReturnArgs} args - Arguments to update many Claims.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, ClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
     */
    upsert<T extends ClaimUpsertArgs>(args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Claim model
   */
  readonly fields: ClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Claim$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Claim$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cpmForm<T extends Claim$cpmFormArgs<ExtArgs> = {}>(args?: Subset<T, Claim$cpmFormArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fppa04Base<T extends Claim$fppa04BaseArgs<ExtArgs> = {}>(args?: Subset<T, Claim$fppa04BaseArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    history<T extends Claim$historyArgs<ExtArgs> = {}>(args?: Subset<T, Claim$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Claim model
   */
  interface ClaimFieldRefs {
    readonly id: FieldRef<"Claim", 'String'>
    readonly docNum: FieldRef<"Claim", 'String'>
    readonly createdByName: FieldRef<"Claim", 'String'>
    readonly approverName: FieldRef<"Claim", 'String'>
    readonly approverPosition: FieldRef<"Claim", 'String'>
    readonly approverDepartment: FieldRef<"Claim", 'String'>
    readonly createdById: FieldRef<"Claim", 'String'>
    readonly approverEmail: FieldRef<"Claim", 'String'>
    readonly approverId: FieldRef<"Claim", 'String'>
    readonly signerId: FieldRef<"Claim", 'String'>
    readonly signerEmail: FieldRef<"Claim", 'String'>
    readonly signerName: FieldRef<"Claim", 'String'>
    readonly signerPosition: FieldRef<"Claim", 'String'>
    readonly status: FieldRef<"Claim", 'ClaimStatus'>
    readonly categoryMain: FieldRef<"Claim", 'String'>
    readonly categorySub: FieldRef<"Claim", 'String'>
    readonly submittedAt: FieldRef<"Claim", 'DateTime'>
    readonly insurerComment: FieldRef<"Claim", 'String'>
    readonly createdAt: FieldRef<"Claim", 'DateTime'>
    readonly updatedAt: FieldRef<"Claim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Claim findUnique
   */
  export type ClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findFirst
   */
  export type ClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }

  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Claim createManyAndReturn
   */
  export type ClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to update.
     */
    limit?: number
  }

  /**
   * Claim updateManyAndReturn
   */
  export type ClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }

  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to delete.
     */
    limit?: number
  }

  /**
   * Claim.attachments
   */
  export type Claim$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Claim.cpmForm
   */
  export type Claim$cpmFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    where?: CPMFormWhereInput
  }

  /**
   * Claim.fppa04Base
   */
  export type Claim$fppa04BaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    where?: Fppa04BaseWhereInput
  }

  /**
   * Claim.history
   */
  export type Claim$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    where?: ClaimHistoryWhereInput
    orderBy?: ClaimHistoryOrderByWithRelationInput | ClaimHistoryOrderByWithRelationInput[]
    cursor?: ClaimHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimHistoryScalarFieldEnum | ClaimHistoryScalarFieldEnum[]
  }

  /**
   * Claim without action
   */
  export type ClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    claimId: string | null
    type: $Enums.AttachmentType | null
    fileName: string | null
    url: string | null
    uploadedAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    claimId: string | null
    type: $Enums.AttachmentType | null
    fileName: string | null
    url: string | null
    uploadedAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    claimId: number
    type: number
    fileName: number
    url: number
    uploadedAt: number
    _all: number
  }


  export type AttachmentMinAggregateInputType = {
    id?: true
    claimId?: true
    type?: true
    fileName?: true
    url?: true
    uploadedAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    claimId?: true
    type?: true
    fileName?: true
    url?: true
    uploadedAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    claimId?: true
    type?: true
    fileName?: true
    url?: true
    uploadedAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    claimId: string
    type: $Enums.AttachmentType
    fileName: string
    url: string
    uploadedAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    type?: boolean
    fileName?: boolean
    url?: boolean
    uploadedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    type?: boolean
    fileName?: boolean
    url?: boolean
    uploadedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    type?: boolean
    fileName?: boolean
    url?: boolean
    uploadedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    claimId?: boolean
    type?: boolean
    fileName?: boolean
    url?: boolean
    uploadedAt?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claimId" | "type" | "fileName" | "url" | "uploadedAt", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claimId: string
      type: $Enums.AttachmentType
      fileName: string
      url: string
      uploadedAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly claimId: FieldRef<"Attachment", 'String'>
    readonly type: FieldRef<"Attachment", 'AttachmentType'>
    readonly fileName: FieldRef<"Attachment", 'String'>
    readonly url: FieldRef<"Attachment", 'String'>
    readonly uploadedAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model CPMForm
   */

  export type AggregateCPMForm = {
    _count: CPMFormCountAggregateOutputType | null
    _avg: CPMFormAvgAggregateOutputType | null
    _sum: CPMFormSumAggregateOutputType | null
    _min: CPMFormMinAggregateOutputType | null
    _max: CPMFormMaxAggregateOutputType | null
  }

  export type CPMFormAvgAggregateOutputType = {
    damageAmount: number | null
    partnerDamageAmount: number | null
  }

  export type CPMFormSumAggregateOutputType = {
    damageAmount: number | null
    partnerDamageAmount: number | null
  }

  export type CPMFormMinAggregateOutputType = {
    claimId: string | null
    accidentDate: Date | null
    accidentTime: string | null
    location: string | null
    cause: string | null
    repairShop: string | null
    repairShopLocation: string | null
    policeDate: Date | null
    policeTime: string | null
    policeStation: string | null
    damageOwnType: string | null
    damageOtherOwn: string | null
    damageDetail: string | null
    damageAmount: number | null
    victimDetail: string | null
    partnerName: string | null
    partnerPhone: string | null
    partnerLocation: string | null
    partnerDamageDetail: string | null
    partnerDamageAmount: number | null
    partnerVictimDetail: string | null
    phoneNum: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CPMFormMaxAggregateOutputType = {
    claimId: string | null
    accidentDate: Date | null
    accidentTime: string | null
    location: string | null
    cause: string | null
    repairShop: string | null
    repairShopLocation: string | null
    policeDate: Date | null
    policeTime: string | null
    policeStation: string | null
    damageOwnType: string | null
    damageOtherOwn: string | null
    damageDetail: string | null
    damageAmount: number | null
    victimDetail: string | null
    partnerName: string | null
    partnerPhone: string | null
    partnerLocation: string | null
    partnerDamageDetail: string | null
    partnerDamageAmount: number | null
    partnerVictimDetail: string | null
    phoneNum: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CPMFormCountAggregateOutputType = {
    claimId: number
    accidentDate: number
    accidentTime: number
    location: number
    cause: number
    repairShop: number
    repairShopLocation: number
    policeDate: number
    policeTime: number
    policeStation: number
    damageOwnType: number
    damageOtherOwn: number
    damageDetail: number
    damageAmount: number
    victimDetail: number
    partnerName: number
    partnerPhone: number
    partnerLocation: number
    partnerDamageDetail: number
    partnerDamageAmount: number
    partnerVictimDetail: number
    phoneNum: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CPMFormAvgAggregateInputType = {
    damageAmount?: true
    partnerDamageAmount?: true
  }

  export type CPMFormSumAggregateInputType = {
    damageAmount?: true
    partnerDamageAmount?: true
  }

  export type CPMFormMinAggregateInputType = {
    claimId?: true
    accidentDate?: true
    accidentTime?: true
    location?: true
    cause?: true
    repairShop?: true
    repairShopLocation?: true
    policeDate?: true
    policeTime?: true
    policeStation?: true
    damageOwnType?: true
    damageOtherOwn?: true
    damageDetail?: true
    damageAmount?: true
    victimDetail?: true
    partnerName?: true
    partnerPhone?: true
    partnerLocation?: true
    partnerDamageDetail?: true
    partnerDamageAmount?: true
    partnerVictimDetail?: true
    phoneNum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CPMFormMaxAggregateInputType = {
    claimId?: true
    accidentDate?: true
    accidentTime?: true
    location?: true
    cause?: true
    repairShop?: true
    repairShopLocation?: true
    policeDate?: true
    policeTime?: true
    policeStation?: true
    damageOwnType?: true
    damageOtherOwn?: true
    damageDetail?: true
    damageAmount?: true
    victimDetail?: true
    partnerName?: true
    partnerPhone?: true
    partnerLocation?: true
    partnerDamageDetail?: true
    partnerDamageAmount?: true
    partnerVictimDetail?: true
    phoneNum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CPMFormCountAggregateInputType = {
    claimId?: true
    accidentDate?: true
    accidentTime?: true
    location?: true
    cause?: true
    repairShop?: true
    repairShopLocation?: true
    policeDate?: true
    policeTime?: true
    policeStation?: true
    damageOwnType?: true
    damageOtherOwn?: true
    damageDetail?: true
    damageAmount?: true
    victimDetail?: true
    partnerName?: true
    partnerPhone?: true
    partnerLocation?: true
    partnerDamageDetail?: true
    partnerDamageAmount?: true
    partnerVictimDetail?: true
    phoneNum?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CPMFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CPMForm to aggregate.
     */
    where?: CPMFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMForms to fetch.
     */
    orderBy?: CPMFormOrderByWithRelationInput | CPMFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CPMFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CPMForms
    **/
    _count?: true | CPMFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CPMFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CPMFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CPMFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CPMFormMaxAggregateInputType
  }

  export type GetCPMFormAggregateType<T extends CPMFormAggregateArgs> = {
        [P in keyof T & keyof AggregateCPMForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCPMForm[P]>
      : GetScalarType<T[P], AggregateCPMForm[P]>
  }




  export type CPMFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CPMFormWhereInput
    orderBy?: CPMFormOrderByWithAggregationInput | CPMFormOrderByWithAggregationInput[]
    by: CPMFormScalarFieldEnum[] | CPMFormScalarFieldEnum
    having?: CPMFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CPMFormCountAggregateInputType | true
    _avg?: CPMFormAvgAggregateInputType
    _sum?: CPMFormSumAggregateInputType
    _min?: CPMFormMinAggregateInputType
    _max?: CPMFormMaxAggregateInputType
  }

  export type CPMFormGroupByOutputType = {
    claimId: string
    accidentDate: Date
    accidentTime: string
    location: string
    cause: string
    repairShop: string | null
    repairShopLocation: string | null
    policeDate: Date | null
    policeTime: string | null
    policeStation: string | null
    damageOwnType: string
    damageOtherOwn: string | null
    damageDetail: string | null
    damageAmount: number | null
    victimDetail: string | null
    partnerName: string | null
    partnerPhone: string | null
    partnerLocation: string | null
    partnerDamageDetail: string | null
    partnerDamageAmount: number | null
    partnerVictimDetail: string | null
    phoneNum: string | null
    createdAt: Date
    updatedAt: Date
    _count: CPMFormCountAggregateOutputType | null
    _avg: CPMFormAvgAggregateOutputType | null
    _sum: CPMFormSumAggregateOutputType | null
    _min: CPMFormMinAggregateOutputType | null
    _max: CPMFormMaxAggregateOutputType | null
  }

  type GetCPMFormGroupByPayload<T extends CPMFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CPMFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CPMFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CPMFormGroupByOutputType[P]>
            : GetScalarType<T[P], CPMFormGroupByOutputType[P]>
        }
      >
    >


  export type CPMFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    claimId?: boolean
    accidentDate?: boolean
    accidentTime?: boolean
    location?: boolean
    cause?: boolean
    repairShop?: boolean
    repairShopLocation?: boolean
    policeDate?: boolean
    policeTime?: boolean
    policeStation?: boolean
    damageOwnType?: boolean
    damageOtherOwn?: boolean
    damageDetail?: boolean
    damageAmount?: boolean
    victimDetail?: boolean
    partnerName?: boolean
    partnerPhone?: boolean
    partnerLocation?: boolean
    partnerDamageDetail?: boolean
    partnerDamageAmount?: boolean
    partnerVictimDetail?: boolean
    phoneNum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMForm"]>

  export type CPMFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    claimId?: boolean
    accidentDate?: boolean
    accidentTime?: boolean
    location?: boolean
    cause?: boolean
    repairShop?: boolean
    repairShopLocation?: boolean
    policeDate?: boolean
    policeTime?: boolean
    policeStation?: boolean
    damageOwnType?: boolean
    damageOtherOwn?: boolean
    damageDetail?: boolean
    damageAmount?: boolean
    victimDetail?: boolean
    partnerName?: boolean
    partnerPhone?: boolean
    partnerLocation?: boolean
    partnerDamageDetail?: boolean
    partnerDamageAmount?: boolean
    partnerVictimDetail?: boolean
    phoneNum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMForm"]>

  export type CPMFormSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    claimId?: boolean
    accidentDate?: boolean
    accidentTime?: boolean
    location?: boolean
    cause?: boolean
    repairShop?: boolean
    repairShopLocation?: boolean
    policeDate?: boolean
    policeTime?: boolean
    policeStation?: boolean
    damageOwnType?: boolean
    damageOtherOwn?: boolean
    damageDetail?: boolean
    damageAmount?: boolean
    victimDetail?: boolean
    partnerName?: boolean
    partnerPhone?: boolean
    partnerLocation?: boolean
    partnerDamageDetail?: boolean
    partnerDamageAmount?: boolean
    partnerVictimDetail?: boolean
    phoneNum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cPMForm"]>

  export type CPMFormSelectScalar = {
    claimId?: boolean
    accidentDate?: boolean
    accidentTime?: boolean
    location?: boolean
    cause?: boolean
    repairShop?: boolean
    repairShopLocation?: boolean
    policeDate?: boolean
    policeTime?: boolean
    policeStation?: boolean
    damageOwnType?: boolean
    damageOtherOwn?: boolean
    damageDetail?: boolean
    damageAmount?: boolean
    victimDetail?: boolean
    partnerName?: boolean
    partnerPhone?: boolean
    partnerLocation?: boolean
    partnerDamageDetail?: boolean
    partnerDamageAmount?: boolean
    partnerVictimDetail?: boolean
    phoneNum?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CPMFormOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"claimId" | "accidentDate" | "accidentTime" | "location" | "cause" | "repairShop" | "repairShopLocation" | "policeDate" | "policeTime" | "policeStation" | "damageOwnType" | "damageOtherOwn" | "damageDetail" | "damageAmount" | "victimDetail" | "partnerName" | "partnerPhone" | "partnerLocation" | "partnerDamageDetail" | "partnerDamageAmount" | "partnerVictimDetail" | "phoneNum" | "createdAt" | "updatedAt", ExtArgs["result"]["cPMForm"]>
  export type CPMFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type CPMFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type CPMFormIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $CPMFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CPMForm"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      claimId: string
      accidentDate: Date
      accidentTime: string
      location: string
      cause: string
      repairShop: string | null
      repairShopLocation: string | null
      policeDate: Date | null
      policeTime: string | null
      policeStation: string | null
      damageOwnType: string
      damageOtherOwn: string | null
      damageDetail: string | null
      damageAmount: number | null
      victimDetail: string | null
      partnerName: string | null
      partnerPhone: string | null
      partnerLocation: string | null
      partnerDamageDetail: string | null
      partnerDamageAmount: number | null
      partnerVictimDetail: string | null
      phoneNum: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cPMForm"]>
    composites: {}
  }

  type CPMFormGetPayload<S extends boolean | null | undefined | CPMFormDefaultArgs> = $Result.GetResult<Prisma.$CPMFormPayload, S>

  type CPMFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CPMFormFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CPMFormCountAggregateInputType | true
    }

  export interface CPMFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CPMForm'], meta: { name: 'CPMForm' } }
    /**
     * Find zero or one CPMForm that matches the filter.
     * @param {CPMFormFindUniqueArgs} args - Arguments to find a CPMForm
     * @example
     * // Get one CPMForm
     * const cPMForm = await prisma.cPMForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CPMFormFindUniqueArgs>(args: SelectSubset<T, CPMFormFindUniqueArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CPMForm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CPMFormFindUniqueOrThrowArgs} args - Arguments to find a CPMForm
     * @example
     * // Get one CPMForm
     * const cPMForm = await prisma.cPMForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CPMFormFindUniqueOrThrowArgs>(args: SelectSubset<T, CPMFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CPMForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMFormFindFirstArgs} args - Arguments to find a CPMForm
     * @example
     * // Get one CPMForm
     * const cPMForm = await prisma.cPMForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CPMFormFindFirstArgs>(args?: SelectSubset<T, CPMFormFindFirstArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CPMForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMFormFindFirstOrThrowArgs} args - Arguments to find a CPMForm
     * @example
     * // Get one CPMForm
     * const cPMForm = await prisma.cPMForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CPMFormFindFirstOrThrowArgs>(args?: SelectSubset<T, CPMFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CPMForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CPMForms
     * const cPMForms = await prisma.cPMForm.findMany()
     * 
     * // Get first 10 CPMForms
     * const cPMForms = await prisma.cPMForm.findMany({ take: 10 })
     * 
     * // Only select the `claimId`
     * const cPMFormWithClaimIdOnly = await prisma.cPMForm.findMany({ select: { claimId: true } })
     * 
     */
    findMany<T extends CPMFormFindManyArgs>(args?: SelectSubset<T, CPMFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CPMForm.
     * @param {CPMFormCreateArgs} args - Arguments to create a CPMForm.
     * @example
     * // Create one CPMForm
     * const CPMForm = await prisma.cPMForm.create({
     *   data: {
     *     // ... data to create a CPMForm
     *   }
     * })
     * 
     */
    create<T extends CPMFormCreateArgs>(args: SelectSubset<T, CPMFormCreateArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CPMForms.
     * @param {CPMFormCreateManyArgs} args - Arguments to create many CPMForms.
     * @example
     * // Create many CPMForms
     * const cPMForm = await prisma.cPMForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CPMFormCreateManyArgs>(args?: SelectSubset<T, CPMFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CPMForms and returns the data saved in the database.
     * @param {CPMFormCreateManyAndReturnArgs} args - Arguments to create many CPMForms.
     * @example
     * // Create many CPMForms
     * const cPMForm = await prisma.cPMForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CPMForms and only return the `claimId`
     * const cPMFormWithClaimIdOnly = await prisma.cPMForm.createManyAndReturn({
     *   select: { claimId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CPMFormCreateManyAndReturnArgs>(args?: SelectSubset<T, CPMFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CPMForm.
     * @param {CPMFormDeleteArgs} args - Arguments to delete one CPMForm.
     * @example
     * // Delete one CPMForm
     * const CPMForm = await prisma.cPMForm.delete({
     *   where: {
     *     // ... filter to delete one CPMForm
     *   }
     * })
     * 
     */
    delete<T extends CPMFormDeleteArgs>(args: SelectSubset<T, CPMFormDeleteArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CPMForm.
     * @param {CPMFormUpdateArgs} args - Arguments to update one CPMForm.
     * @example
     * // Update one CPMForm
     * const cPMForm = await prisma.cPMForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CPMFormUpdateArgs>(args: SelectSubset<T, CPMFormUpdateArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CPMForms.
     * @param {CPMFormDeleteManyArgs} args - Arguments to filter CPMForms to delete.
     * @example
     * // Delete a few CPMForms
     * const { count } = await prisma.cPMForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CPMFormDeleteManyArgs>(args?: SelectSubset<T, CPMFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CPMForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CPMForms
     * const cPMForm = await prisma.cPMForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CPMFormUpdateManyArgs>(args: SelectSubset<T, CPMFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CPMForms and returns the data updated in the database.
     * @param {CPMFormUpdateManyAndReturnArgs} args - Arguments to update many CPMForms.
     * @example
     * // Update many CPMForms
     * const cPMForm = await prisma.cPMForm.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CPMForms and only return the `claimId`
     * const cPMFormWithClaimIdOnly = await prisma.cPMForm.updateManyAndReturn({
     *   select: { claimId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CPMFormUpdateManyAndReturnArgs>(args: SelectSubset<T, CPMFormUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CPMForm.
     * @param {CPMFormUpsertArgs} args - Arguments to update or create a CPMForm.
     * @example
     * // Update or create a CPMForm
     * const cPMForm = await prisma.cPMForm.upsert({
     *   create: {
     *     // ... data to create a CPMForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CPMForm we want to update
     *   }
     * })
     */
    upsert<T extends CPMFormUpsertArgs>(args: SelectSubset<T, CPMFormUpsertArgs<ExtArgs>>): Prisma__CPMFormClient<$Result.GetResult<Prisma.$CPMFormPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CPMForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMFormCountArgs} args - Arguments to filter CPMForms to count.
     * @example
     * // Count the number of CPMForms
     * const count = await prisma.cPMForm.count({
     *   where: {
     *     // ... the filter for the CPMForms we want to count
     *   }
     * })
    **/
    count<T extends CPMFormCountArgs>(
      args?: Subset<T, CPMFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CPMFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CPMForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CPMFormAggregateArgs>(args: Subset<T, CPMFormAggregateArgs>): Prisma.PrismaPromise<GetCPMFormAggregateType<T>>

    /**
     * Group by CPMForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CPMFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CPMFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CPMFormGroupByArgs['orderBy'] }
        : { orderBy?: CPMFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CPMFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCPMFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CPMForm model
   */
  readonly fields: CPMFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CPMForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CPMFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CPMForm model
   */
  interface CPMFormFieldRefs {
    readonly claimId: FieldRef<"CPMForm", 'String'>
    readonly accidentDate: FieldRef<"CPMForm", 'DateTime'>
    readonly accidentTime: FieldRef<"CPMForm", 'String'>
    readonly location: FieldRef<"CPMForm", 'String'>
    readonly cause: FieldRef<"CPMForm", 'String'>
    readonly repairShop: FieldRef<"CPMForm", 'String'>
    readonly repairShopLocation: FieldRef<"CPMForm", 'String'>
    readonly policeDate: FieldRef<"CPMForm", 'DateTime'>
    readonly policeTime: FieldRef<"CPMForm", 'String'>
    readonly policeStation: FieldRef<"CPMForm", 'String'>
    readonly damageOwnType: FieldRef<"CPMForm", 'String'>
    readonly damageOtherOwn: FieldRef<"CPMForm", 'String'>
    readonly damageDetail: FieldRef<"CPMForm", 'String'>
    readonly damageAmount: FieldRef<"CPMForm", 'Float'>
    readonly victimDetail: FieldRef<"CPMForm", 'String'>
    readonly partnerName: FieldRef<"CPMForm", 'String'>
    readonly partnerPhone: FieldRef<"CPMForm", 'String'>
    readonly partnerLocation: FieldRef<"CPMForm", 'String'>
    readonly partnerDamageDetail: FieldRef<"CPMForm", 'String'>
    readonly partnerDamageAmount: FieldRef<"CPMForm", 'Float'>
    readonly partnerVictimDetail: FieldRef<"CPMForm", 'String'>
    readonly phoneNum: FieldRef<"CPMForm", 'String'>
    readonly createdAt: FieldRef<"CPMForm", 'DateTime'>
    readonly updatedAt: FieldRef<"CPMForm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CPMForm findUnique
   */
  export type CPMFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * Filter, which CPMForm to fetch.
     */
    where: CPMFormWhereUniqueInput
  }

  /**
   * CPMForm findUniqueOrThrow
   */
  export type CPMFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * Filter, which CPMForm to fetch.
     */
    where: CPMFormWhereUniqueInput
  }

  /**
   * CPMForm findFirst
   */
  export type CPMFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * Filter, which CPMForm to fetch.
     */
    where?: CPMFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMForms to fetch.
     */
    orderBy?: CPMFormOrderByWithRelationInput | CPMFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CPMForms.
     */
    cursor?: CPMFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CPMForms.
     */
    distinct?: CPMFormScalarFieldEnum | CPMFormScalarFieldEnum[]
  }

  /**
   * CPMForm findFirstOrThrow
   */
  export type CPMFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * Filter, which CPMForm to fetch.
     */
    where?: CPMFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMForms to fetch.
     */
    orderBy?: CPMFormOrderByWithRelationInput | CPMFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CPMForms.
     */
    cursor?: CPMFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CPMForms.
     */
    distinct?: CPMFormScalarFieldEnum | CPMFormScalarFieldEnum[]
  }

  /**
   * CPMForm findMany
   */
  export type CPMFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * Filter, which CPMForms to fetch.
     */
    where?: CPMFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CPMForms to fetch.
     */
    orderBy?: CPMFormOrderByWithRelationInput | CPMFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CPMForms.
     */
    cursor?: CPMFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CPMForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CPMForms.
     */
    skip?: number
    distinct?: CPMFormScalarFieldEnum | CPMFormScalarFieldEnum[]
  }

  /**
   * CPMForm create
   */
  export type CPMFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * The data needed to create a CPMForm.
     */
    data: XOR<CPMFormCreateInput, CPMFormUncheckedCreateInput>
  }

  /**
   * CPMForm createMany
   */
  export type CPMFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CPMForms.
     */
    data: CPMFormCreateManyInput | CPMFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CPMForm createManyAndReturn
   */
  export type CPMFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * The data used to create many CPMForms.
     */
    data: CPMFormCreateManyInput | CPMFormCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CPMForm update
   */
  export type CPMFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * The data needed to update a CPMForm.
     */
    data: XOR<CPMFormUpdateInput, CPMFormUncheckedUpdateInput>
    /**
     * Choose, which CPMForm to update.
     */
    where: CPMFormWhereUniqueInput
  }

  /**
   * CPMForm updateMany
   */
  export type CPMFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CPMForms.
     */
    data: XOR<CPMFormUpdateManyMutationInput, CPMFormUncheckedUpdateManyInput>
    /**
     * Filter which CPMForms to update
     */
    where?: CPMFormWhereInput
    /**
     * Limit how many CPMForms to update.
     */
    limit?: number
  }

  /**
   * CPMForm updateManyAndReturn
   */
  export type CPMFormUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * The data used to update CPMForms.
     */
    data: XOR<CPMFormUpdateManyMutationInput, CPMFormUncheckedUpdateManyInput>
    /**
     * Filter which CPMForms to update
     */
    where?: CPMFormWhereInput
    /**
     * Limit how many CPMForms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CPMForm upsert
   */
  export type CPMFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * The filter to search for the CPMForm to update in case it exists.
     */
    where: CPMFormWhereUniqueInput
    /**
     * In case the CPMForm found by the `where` argument doesn't exist, create a new CPMForm with this data.
     */
    create: XOR<CPMFormCreateInput, CPMFormUncheckedCreateInput>
    /**
     * In case the CPMForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CPMFormUpdateInput, CPMFormUncheckedUpdateInput>
  }

  /**
   * CPMForm delete
   */
  export type CPMFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
    /**
     * Filter which CPMForm to delete.
     */
    where: CPMFormWhereUniqueInput
  }

  /**
   * CPMForm deleteMany
   */
  export type CPMFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CPMForms to delete
     */
    where?: CPMFormWhereInput
    /**
     * Limit how many CPMForms to delete.
     */
    limit?: number
  }

  /**
   * CPMForm without action
   */
  export type CPMFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CPMForm
     */
    select?: CPMFormSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CPMForm
     */
    omit?: CPMFormOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CPMFormInclude<ExtArgs> | null
  }


  /**
   * Model Fppa04Base
   */

  export type AggregateFppa04Base = {
    _count: Fppa04BaseCountAggregateOutputType | null
    _min: Fppa04BaseMinAggregateOutputType | null
    _max: Fppa04BaseMaxAggregateOutputType | null
  }

  export type Fppa04BaseMinAggregateOutputType = {
    id: string | null
    claimId: string | null
    mainType: string | null
    subType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Fppa04BaseMaxAggregateOutputType = {
    id: string | null
    claimId: string | null
    mainType: string | null
    subType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Fppa04BaseCountAggregateOutputType = {
    id: number
    claimId: number
    mainType: number
    subType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Fppa04BaseMinAggregateInputType = {
    id?: true
    claimId?: true
    mainType?: true
    subType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Fppa04BaseMaxAggregateInputType = {
    id?: true
    claimId?: true
    mainType?: true
    subType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Fppa04BaseCountAggregateInputType = {
    id?: true
    claimId?: true
    mainType?: true
    subType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Fppa04BaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fppa04Base to aggregate.
     */
    where?: Fppa04BaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04Bases to fetch.
     */
    orderBy?: Fppa04BaseOrderByWithRelationInput | Fppa04BaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Fppa04BaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04Bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04Bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fppa04Bases
    **/
    _count?: true | Fppa04BaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fppa04BaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fppa04BaseMaxAggregateInputType
  }

  export type GetFppa04BaseAggregateType<T extends Fppa04BaseAggregateArgs> = {
        [P in keyof T & keyof AggregateFppa04Base]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFppa04Base[P]>
      : GetScalarType<T[P], AggregateFppa04Base[P]>
  }




  export type Fppa04BaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Fppa04BaseWhereInput
    orderBy?: Fppa04BaseOrderByWithAggregationInput | Fppa04BaseOrderByWithAggregationInput[]
    by: Fppa04BaseScalarFieldEnum[] | Fppa04BaseScalarFieldEnum
    having?: Fppa04BaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fppa04BaseCountAggregateInputType | true
    _min?: Fppa04BaseMinAggregateInputType
    _max?: Fppa04BaseMaxAggregateInputType
  }

  export type Fppa04BaseGroupByOutputType = {
    id: string
    claimId: string
    mainType: string
    subType: string
    createdAt: Date
    updatedAt: Date
    _count: Fppa04BaseCountAggregateOutputType | null
    _min: Fppa04BaseMinAggregateOutputType | null
    _max: Fppa04BaseMaxAggregateOutputType | null
  }

  type GetFppa04BaseGroupByPayload<T extends Fppa04BaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fppa04BaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fppa04BaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fppa04BaseGroupByOutputType[P]>
            : GetScalarType<T[P], Fppa04BaseGroupByOutputType[P]>
        }
      >
    >


  export type Fppa04BaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    mainType?: boolean
    subType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    cpmVariant?: boolean | Fppa04Base$cpmVariantArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04Base"]>

  export type Fppa04BaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    mainType?: boolean
    subType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04Base"]>

  export type Fppa04BaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    mainType?: boolean
    subType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04Base"]>

  export type Fppa04BaseSelectScalar = {
    id?: boolean
    claimId?: boolean
    mainType?: boolean
    subType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Fppa04BaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claimId" | "mainType" | "subType" | "createdAt" | "updatedAt", ExtArgs["result"]["fppa04Base"]>
  export type Fppa04BaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
    cpmVariant?: boolean | Fppa04Base$cpmVariantArgs<ExtArgs>
  }
  export type Fppa04BaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type Fppa04BaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $Fppa04BasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fppa04Base"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
      cpmVariant: Prisma.$Fppa04CPMPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claimId: string
      mainType: string
      subType: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fppa04Base"]>
    composites: {}
  }

  type Fppa04BaseGetPayload<S extends boolean | null | undefined | Fppa04BaseDefaultArgs> = $Result.GetResult<Prisma.$Fppa04BasePayload, S>

  type Fppa04BaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Fppa04BaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Fppa04BaseCountAggregateInputType | true
    }

  export interface Fppa04BaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fppa04Base'], meta: { name: 'Fppa04Base' } }
    /**
     * Find zero or one Fppa04Base that matches the filter.
     * @param {Fppa04BaseFindUniqueArgs} args - Arguments to find a Fppa04Base
     * @example
     * // Get one Fppa04Base
     * const fppa04Base = await prisma.fppa04Base.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Fppa04BaseFindUniqueArgs>(args: SelectSubset<T, Fppa04BaseFindUniqueArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fppa04Base that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Fppa04BaseFindUniqueOrThrowArgs} args - Arguments to find a Fppa04Base
     * @example
     * // Get one Fppa04Base
     * const fppa04Base = await prisma.fppa04Base.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Fppa04BaseFindUniqueOrThrowArgs>(args: SelectSubset<T, Fppa04BaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fppa04Base that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04BaseFindFirstArgs} args - Arguments to find a Fppa04Base
     * @example
     * // Get one Fppa04Base
     * const fppa04Base = await prisma.fppa04Base.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Fppa04BaseFindFirstArgs>(args?: SelectSubset<T, Fppa04BaseFindFirstArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fppa04Base that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04BaseFindFirstOrThrowArgs} args - Arguments to find a Fppa04Base
     * @example
     * // Get one Fppa04Base
     * const fppa04Base = await prisma.fppa04Base.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Fppa04BaseFindFirstOrThrowArgs>(args?: SelectSubset<T, Fppa04BaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fppa04Bases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04BaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fppa04Bases
     * const fppa04Bases = await prisma.fppa04Base.findMany()
     * 
     * // Get first 10 Fppa04Bases
     * const fppa04Bases = await prisma.fppa04Base.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fppa04BaseWithIdOnly = await prisma.fppa04Base.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Fppa04BaseFindManyArgs>(args?: SelectSubset<T, Fppa04BaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fppa04Base.
     * @param {Fppa04BaseCreateArgs} args - Arguments to create a Fppa04Base.
     * @example
     * // Create one Fppa04Base
     * const Fppa04Base = await prisma.fppa04Base.create({
     *   data: {
     *     // ... data to create a Fppa04Base
     *   }
     * })
     * 
     */
    create<T extends Fppa04BaseCreateArgs>(args: SelectSubset<T, Fppa04BaseCreateArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fppa04Bases.
     * @param {Fppa04BaseCreateManyArgs} args - Arguments to create many Fppa04Bases.
     * @example
     * // Create many Fppa04Bases
     * const fppa04Base = await prisma.fppa04Base.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Fppa04BaseCreateManyArgs>(args?: SelectSubset<T, Fppa04BaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fppa04Bases and returns the data saved in the database.
     * @param {Fppa04BaseCreateManyAndReturnArgs} args - Arguments to create many Fppa04Bases.
     * @example
     * // Create many Fppa04Bases
     * const fppa04Base = await prisma.fppa04Base.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fppa04Bases and only return the `id`
     * const fppa04BaseWithIdOnly = await prisma.fppa04Base.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Fppa04BaseCreateManyAndReturnArgs>(args?: SelectSubset<T, Fppa04BaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fppa04Base.
     * @param {Fppa04BaseDeleteArgs} args - Arguments to delete one Fppa04Base.
     * @example
     * // Delete one Fppa04Base
     * const Fppa04Base = await prisma.fppa04Base.delete({
     *   where: {
     *     // ... filter to delete one Fppa04Base
     *   }
     * })
     * 
     */
    delete<T extends Fppa04BaseDeleteArgs>(args: SelectSubset<T, Fppa04BaseDeleteArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fppa04Base.
     * @param {Fppa04BaseUpdateArgs} args - Arguments to update one Fppa04Base.
     * @example
     * // Update one Fppa04Base
     * const fppa04Base = await prisma.fppa04Base.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Fppa04BaseUpdateArgs>(args: SelectSubset<T, Fppa04BaseUpdateArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fppa04Bases.
     * @param {Fppa04BaseDeleteManyArgs} args - Arguments to filter Fppa04Bases to delete.
     * @example
     * // Delete a few Fppa04Bases
     * const { count } = await prisma.fppa04Base.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Fppa04BaseDeleteManyArgs>(args?: SelectSubset<T, Fppa04BaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fppa04Bases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04BaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fppa04Bases
     * const fppa04Base = await prisma.fppa04Base.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Fppa04BaseUpdateManyArgs>(args: SelectSubset<T, Fppa04BaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fppa04Bases and returns the data updated in the database.
     * @param {Fppa04BaseUpdateManyAndReturnArgs} args - Arguments to update many Fppa04Bases.
     * @example
     * // Update many Fppa04Bases
     * const fppa04Base = await prisma.fppa04Base.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fppa04Bases and only return the `id`
     * const fppa04BaseWithIdOnly = await prisma.fppa04Base.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Fppa04BaseUpdateManyAndReturnArgs>(args: SelectSubset<T, Fppa04BaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fppa04Base.
     * @param {Fppa04BaseUpsertArgs} args - Arguments to update or create a Fppa04Base.
     * @example
     * // Update or create a Fppa04Base
     * const fppa04Base = await prisma.fppa04Base.upsert({
     *   create: {
     *     // ... data to create a Fppa04Base
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fppa04Base we want to update
     *   }
     * })
     */
    upsert<T extends Fppa04BaseUpsertArgs>(args: SelectSubset<T, Fppa04BaseUpsertArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fppa04Bases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04BaseCountArgs} args - Arguments to filter Fppa04Bases to count.
     * @example
     * // Count the number of Fppa04Bases
     * const count = await prisma.fppa04Base.count({
     *   where: {
     *     // ... the filter for the Fppa04Bases we want to count
     *   }
     * })
    **/
    count<T extends Fppa04BaseCountArgs>(
      args?: Subset<T, Fppa04BaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fppa04BaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fppa04Base.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04BaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fppa04BaseAggregateArgs>(args: Subset<T, Fppa04BaseAggregateArgs>): Prisma.PrismaPromise<GetFppa04BaseAggregateType<T>>

    /**
     * Group by Fppa04Base.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04BaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fppa04BaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fppa04BaseGroupByArgs['orderBy'] }
        : { orderBy?: Fppa04BaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fppa04BaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFppa04BaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fppa04Base model
   */
  readonly fields: Fppa04BaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fppa04Base.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Fppa04BaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cpmVariant<T extends Fppa04Base$cpmVariantArgs<ExtArgs> = {}>(args?: Subset<T, Fppa04Base$cpmVariantArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fppa04Base model
   */
  interface Fppa04BaseFieldRefs {
    readonly id: FieldRef<"Fppa04Base", 'String'>
    readonly claimId: FieldRef<"Fppa04Base", 'String'>
    readonly mainType: FieldRef<"Fppa04Base", 'String'>
    readonly subType: FieldRef<"Fppa04Base", 'String'>
    readonly createdAt: FieldRef<"Fppa04Base", 'DateTime'>
    readonly updatedAt: FieldRef<"Fppa04Base", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fppa04Base findUnique
   */
  export type Fppa04BaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04Base to fetch.
     */
    where: Fppa04BaseWhereUniqueInput
  }

  /**
   * Fppa04Base findUniqueOrThrow
   */
  export type Fppa04BaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04Base to fetch.
     */
    where: Fppa04BaseWhereUniqueInput
  }

  /**
   * Fppa04Base findFirst
   */
  export type Fppa04BaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04Base to fetch.
     */
    where?: Fppa04BaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04Bases to fetch.
     */
    orderBy?: Fppa04BaseOrderByWithRelationInput | Fppa04BaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fppa04Bases.
     */
    cursor?: Fppa04BaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04Bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04Bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fppa04Bases.
     */
    distinct?: Fppa04BaseScalarFieldEnum | Fppa04BaseScalarFieldEnum[]
  }

  /**
   * Fppa04Base findFirstOrThrow
   */
  export type Fppa04BaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04Base to fetch.
     */
    where?: Fppa04BaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04Bases to fetch.
     */
    orderBy?: Fppa04BaseOrderByWithRelationInput | Fppa04BaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fppa04Bases.
     */
    cursor?: Fppa04BaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04Bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04Bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fppa04Bases.
     */
    distinct?: Fppa04BaseScalarFieldEnum | Fppa04BaseScalarFieldEnum[]
  }

  /**
   * Fppa04Base findMany
   */
  export type Fppa04BaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04Bases to fetch.
     */
    where?: Fppa04BaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04Bases to fetch.
     */
    orderBy?: Fppa04BaseOrderByWithRelationInput | Fppa04BaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fppa04Bases.
     */
    cursor?: Fppa04BaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04Bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04Bases.
     */
    skip?: number
    distinct?: Fppa04BaseScalarFieldEnum | Fppa04BaseScalarFieldEnum[]
  }

  /**
   * Fppa04Base create
   */
  export type Fppa04BaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Fppa04Base.
     */
    data: XOR<Fppa04BaseCreateInput, Fppa04BaseUncheckedCreateInput>
  }

  /**
   * Fppa04Base createMany
   */
  export type Fppa04BaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fppa04Bases.
     */
    data: Fppa04BaseCreateManyInput | Fppa04BaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fppa04Base createManyAndReturn
   */
  export type Fppa04BaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * The data used to create many Fppa04Bases.
     */
    data: Fppa04BaseCreateManyInput | Fppa04BaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fppa04Base update
   */
  export type Fppa04BaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Fppa04Base.
     */
    data: XOR<Fppa04BaseUpdateInput, Fppa04BaseUncheckedUpdateInput>
    /**
     * Choose, which Fppa04Base to update.
     */
    where: Fppa04BaseWhereUniqueInput
  }

  /**
   * Fppa04Base updateMany
   */
  export type Fppa04BaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fppa04Bases.
     */
    data: XOR<Fppa04BaseUpdateManyMutationInput, Fppa04BaseUncheckedUpdateManyInput>
    /**
     * Filter which Fppa04Bases to update
     */
    where?: Fppa04BaseWhereInput
    /**
     * Limit how many Fppa04Bases to update.
     */
    limit?: number
  }

  /**
   * Fppa04Base updateManyAndReturn
   */
  export type Fppa04BaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * The data used to update Fppa04Bases.
     */
    data: XOR<Fppa04BaseUpdateManyMutationInput, Fppa04BaseUncheckedUpdateManyInput>
    /**
     * Filter which Fppa04Bases to update
     */
    where?: Fppa04BaseWhereInput
    /**
     * Limit how many Fppa04Bases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fppa04Base upsert
   */
  export type Fppa04BaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Fppa04Base to update in case it exists.
     */
    where: Fppa04BaseWhereUniqueInput
    /**
     * In case the Fppa04Base found by the `where` argument doesn't exist, create a new Fppa04Base with this data.
     */
    create: XOR<Fppa04BaseCreateInput, Fppa04BaseUncheckedCreateInput>
    /**
     * In case the Fppa04Base was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Fppa04BaseUpdateInput, Fppa04BaseUncheckedUpdateInput>
  }

  /**
   * Fppa04Base delete
   */
  export type Fppa04BaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
    /**
     * Filter which Fppa04Base to delete.
     */
    where: Fppa04BaseWhereUniqueInput
  }

  /**
   * Fppa04Base deleteMany
   */
  export type Fppa04BaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fppa04Bases to delete
     */
    where?: Fppa04BaseWhereInput
    /**
     * Limit how many Fppa04Bases to delete.
     */
    limit?: number
  }

  /**
   * Fppa04Base.cpmVariant
   */
  export type Fppa04Base$cpmVariantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    where?: Fppa04CPMWhereInput
  }

  /**
   * Fppa04Base without action
   */
  export type Fppa04BaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04Base
     */
    select?: Fppa04BaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04Base
     */
    omit?: Fppa04BaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04BaseInclude<ExtArgs> | null
  }


  /**
   * Model Fppa04CPM
   */

  export type AggregateFppa04CPM = {
    _count: Fppa04CPMCountAggregateOutputType | null
    _avg: Fppa04CPMAvgAggregateOutputType | null
    _sum: Fppa04CPMSumAggregateOutputType | null
    _min: Fppa04CPMMinAggregateOutputType | null
    _max: Fppa04CPMMaxAggregateOutputType | null
  }

  export type Fppa04CPMAvgAggregateOutputType = {
    productionYear: number | null
    insurancePayout: number | null
    netAmount: number | null
  }

  export type Fppa04CPMSumAggregateOutputType = {
    productionYear: number | null
    insurancePayout: number | null
    netAmount: number | null
  }

  export type Fppa04CPMMinAggregateOutputType = {
    baseId: string | null
    eventType: string | null
    claimRefNumber: string | null
    eventDescription: string | null
    productionYear: number | null
    accidentDate: Date | null
    reportedDate: Date | null
    receivedDocDate: Date | null
    company: string | null
    factory: string | null
    policyNumber: string | null
    surveyorRefNumber: string | null
    insurancePayout: number | null
    netAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Fppa04CPMMaxAggregateOutputType = {
    baseId: string | null
    eventType: string | null
    claimRefNumber: string | null
    eventDescription: string | null
    productionYear: number | null
    accidentDate: Date | null
    reportedDate: Date | null
    receivedDocDate: Date | null
    company: string | null
    factory: string | null
    policyNumber: string | null
    surveyorRefNumber: string | null
    insurancePayout: number | null
    netAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Fppa04CPMCountAggregateOutputType = {
    baseId: number
    eventType: number
    claimRefNumber: number
    eventDescription: number
    productionYear: number
    accidentDate: number
    reportedDate: number
    receivedDocDate: number
    company: number
    factory: number
    policyNumber: number
    surveyorRefNumber: number
    insurancePayout: number
    netAmount: number
    signatureFiles: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Fppa04CPMAvgAggregateInputType = {
    productionYear?: true
    insurancePayout?: true
    netAmount?: true
  }

  export type Fppa04CPMSumAggregateInputType = {
    productionYear?: true
    insurancePayout?: true
    netAmount?: true
  }

  export type Fppa04CPMMinAggregateInputType = {
    baseId?: true
    eventType?: true
    claimRefNumber?: true
    eventDescription?: true
    productionYear?: true
    accidentDate?: true
    reportedDate?: true
    receivedDocDate?: true
    company?: true
    factory?: true
    policyNumber?: true
    surveyorRefNumber?: true
    insurancePayout?: true
    netAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Fppa04CPMMaxAggregateInputType = {
    baseId?: true
    eventType?: true
    claimRefNumber?: true
    eventDescription?: true
    productionYear?: true
    accidentDate?: true
    reportedDate?: true
    receivedDocDate?: true
    company?: true
    factory?: true
    policyNumber?: true
    surveyorRefNumber?: true
    insurancePayout?: true
    netAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Fppa04CPMCountAggregateInputType = {
    baseId?: true
    eventType?: true
    claimRefNumber?: true
    eventDescription?: true
    productionYear?: true
    accidentDate?: true
    reportedDate?: true
    receivedDocDate?: true
    company?: true
    factory?: true
    policyNumber?: true
    surveyorRefNumber?: true
    insurancePayout?: true
    netAmount?: true
    signatureFiles?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Fppa04CPMAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fppa04CPM to aggregate.
     */
    where?: Fppa04CPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04CPMS to fetch.
     */
    orderBy?: Fppa04CPMOrderByWithRelationInput | Fppa04CPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Fppa04CPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04CPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04CPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fppa04CPMS
    **/
    _count?: true | Fppa04CPMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fppa04CPMAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fppa04CPMSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fppa04CPMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fppa04CPMMaxAggregateInputType
  }

  export type GetFppa04CPMAggregateType<T extends Fppa04CPMAggregateArgs> = {
        [P in keyof T & keyof AggregateFppa04CPM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFppa04CPM[P]>
      : GetScalarType<T[P], AggregateFppa04CPM[P]>
  }




  export type Fppa04CPMGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Fppa04CPMWhereInput
    orderBy?: Fppa04CPMOrderByWithAggregationInput | Fppa04CPMOrderByWithAggregationInput[]
    by: Fppa04CPMScalarFieldEnum[] | Fppa04CPMScalarFieldEnum
    having?: Fppa04CPMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fppa04CPMCountAggregateInputType | true
    _avg?: Fppa04CPMAvgAggregateInputType
    _sum?: Fppa04CPMSumAggregateInputType
    _min?: Fppa04CPMMinAggregateInputType
    _max?: Fppa04CPMMaxAggregateInputType
  }

  export type Fppa04CPMGroupByOutputType = {
    baseId: string
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date
    reportedDate: Date
    receivedDocDate: Date
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles: string[]
    createdAt: Date
    updatedAt: Date
    _count: Fppa04CPMCountAggregateOutputType | null
    _avg: Fppa04CPMAvgAggregateOutputType | null
    _sum: Fppa04CPMSumAggregateOutputType | null
    _min: Fppa04CPMMinAggregateOutputType | null
    _max: Fppa04CPMMaxAggregateOutputType | null
  }

  type GetFppa04CPMGroupByPayload<T extends Fppa04CPMGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fppa04CPMGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fppa04CPMGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fppa04CPMGroupByOutputType[P]>
            : GetScalarType<T[P], Fppa04CPMGroupByOutputType[P]>
        }
      >
    >


  export type Fppa04CPMSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    baseId?: boolean
    eventType?: boolean
    claimRefNumber?: boolean
    eventDescription?: boolean
    productionYear?: boolean
    accidentDate?: boolean
    reportedDate?: boolean
    receivedDocDate?: boolean
    company?: boolean
    factory?: boolean
    policyNumber?: boolean
    surveyorRefNumber?: boolean
    insurancePayout?: boolean
    netAmount?: boolean
    signatureFiles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    base?: boolean | Fppa04BaseDefaultArgs<ExtArgs>
    items?: boolean | Fppa04CPM$itemsArgs<ExtArgs>
    adjustments?: boolean | Fppa04CPM$adjustmentsArgs<ExtArgs>
    _count?: boolean | Fppa04CPMCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04CPM"]>

  export type Fppa04CPMSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    baseId?: boolean
    eventType?: boolean
    claimRefNumber?: boolean
    eventDescription?: boolean
    productionYear?: boolean
    accidentDate?: boolean
    reportedDate?: boolean
    receivedDocDate?: boolean
    company?: boolean
    factory?: boolean
    policyNumber?: boolean
    surveyorRefNumber?: boolean
    insurancePayout?: boolean
    netAmount?: boolean
    signatureFiles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    base?: boolean | Fppa04BaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04CPM"]>

  export type Fppa04CPMSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    baseId?: boolean
    eventType?: boolean
    claimRefNumber?: boolean
    eventDescription?: boolean
    productionYear?: boolean
    accidentDate?: boolean
    reportedDate?: boolean
    receivedDocDate?: boolean
    company?: boolean
    factory?: boolean
    policyNumber?: boolean
    surveyorRefNumber?: boolean
    insurancePayout?: boolean
    netAmount?: boolean
    signatureFiles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    base?: boolean | Fppa04BaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04CPM"]>

  export type Fppa04CPMSelectScalar = {
    baseId?: boolean
    eventType?: boolean
    claimRefNumber?: boolean
    eventDescription?: boolean
    productionYear?: boolean
    accidentDate?: boolean
    reportedDate?: boolean
    receivedDocDate?: boolean
    company?: boolean
    factory?: boolean
    policyNumber?: boolean
    surveyorRefNumber?: boolean
    insurancePayout?: boolean
    netAmount?: boolean
    signatureFiles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Fppa04CPMOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"baseId" | "eventType" | "claimRefNumber" | "eventDescription" | "productionYear" | "accidentDate" | "reportedDate" | "receivedDocDate" | "company" | "factory" | "policyNumber" | "surveyorRefNumber" | "insurancePayout" | "netAmount" | "signatureFiles" | "createdAt" | "updatedAt", ExtArgs["result"]["fppa04CPM"]>
  export type Fppa04CPMInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    base?: boolean | Fppa04BaseDefaultArgs<ExtArgs>
    items?: boolean | Fppa04CPM$itemsArgs<ExtArgs>
    adjustments?: boolean | Fppa04CPM$adjustmentsArgs<ExtArgs>
    _count?: boolean | Fppa04CPMCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Fppa04CPMIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    base?: boolean | Fppa04BaseDefaultArgs<ExtArgs>
  }
  export type Fppa04CPMIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    base?: boolean | Fppa04BaseDefaultArgs<ExtArgs>
  }

  export type $Fppa04CPMPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fppa04CPM"
    objects: {
      base: Prisma.$Fppa04BasePayload<ExtArgs>
      items: Prisma.$Fppa04ItemCPMPayload<ExtArgs>[]
      adjustments: Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      baseId: string
      eventType: string
      claimRefNumber: string
      eventDescription: string
      productionYear: number
      accidentDate: Date
      reportedDate: Date
      receivedDocDate: Date
      company: string
      factory: string
      policyNumber: string
      surveyorRefNumber: string
      insurancePayout: number
      netAmount: number
      signatureFiles: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fppa04CPM"]>
    composites: {}
  }

  type Fppa04CPMGetPayload<S extends boolean | null | undefined | Fppa04CPMDefaultArgs> = $Result.GetResult<Prisma.$Fppa04CPMPayload, S>

  type Fppa04CPMCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Fppa04CPMFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Fppa04CPMCountAggregateInputType | true
    }

  export interface Fppa04CPMDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fppa04CPM'], meta: { name: 'Fppa04CPM' } }
    /**
     * Find zero or one Fppa04CPM that matches the filter.
     * @param {Fppa04CPMFindUniqueArgs} args - Arguments to find a Fppa04CPM
     * @example
     * // Get one Fppa04CPM
     * const fppa04CPM = await prisma.fppa04CPM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Fppa04CPMFindUniqueArgs>(args: SelectSubset<T, Fppa04CPMFindUniqueArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fppa04CPM that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Fppa04CPMFindUniqueOrThrowArgs} args - Arguments to find a Fppa04CPM
     * @example
     * // Get one Fppa04CPM
     * const fppa04CPM = await prisma.fppa04CPM.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Fppa04CPMFindUniqueOrThrowArgs>(args: SelectSubset<T, Fppa04CPMFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fppa04CPM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04CPMFindFirstArgs} args - Arguments to find a Fppa04CPM
     * @example
     * // Get one Fppa04CPM
     * const fppa04CPM = await prisma.fppa04CPM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Fppa04CPMFindFirstArgs>(args?: SelectSubset<T, Fppa04CPMFindFirstArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fppa04CPM that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04CPMFindFirstOrThrowArgs} args - Arguments to find a Fppa04CPM
     * @example
     * // Get one Fppa04CPM
     * const fppa04CPM = await prisma.fppa04CPM.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Fppa04CPMFindFirstOrThrowArgs>(args?: SelectSubset<T, Fppa04CPMFindFirstOrThrowArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fppa04CPMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04CPMFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fppa04CPMS
     * const fppa04CPMS = await prisma.fppa04CPM.findMany()
     * 
     * // Get first 10 Fppa04CPMS
     * const fppa04CPMS = await prisma.fppa04CPM.findMany({ take: 10 })
     * 
     * // Only select the `baseId`
     * const fppa04CPMWithBaseIdOnly = await prisma.fppa04CPM.findMany({ select: { baseId: true } })
     * 
     */
    findMany<T extends Fppa04CPMFindManyArgs>(args?: SelectSubset<T, Fppa04CPMFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fppa04CPM.
     * @param {Fppa04CPMCreateArgs} args - Arguments to create a Fppa04CPM.
     * @example
     * // Create one Fppa04CPM
     * const Fppa04CPM = await prisma.fppa04CPM.create({
     *   data: {
     *     // ... data to create a Fppa04CPM
     *   }
     * })
     * 
     */
    create<T extends Fppa04CPMCreateArgs>(args: SelectSubset<T, Fppa04CPMCreateArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fppa04CPMS.
     * @param {Fppa04CPMCreateManyArgs} args - Arguments to create many Fppa04CPMS.
     * @example
     * // Create many Fppa04CPMS
     * const fppa04CPM = await prisma.fppa04CPM.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Fppa04CPMCreateManyArgs>(args?: SelectSubset<T, Fppa04CPMCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fppa04CPMS and returns the data saved in the database.
     * @param {Fppa04CPMCreateManyAndReturnArgs} args - Arguments to create many Fppa04CPMS.
     * @example
     * // Create many Fppa04CPMS
     * const fppa04CPM = await prisma.fppa04CPM.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fppa04CPMS and only return the `baseId`
     * const fppa04CPMWithBaseIdOnly = await prisma.fppa04CPM.createManyAndReturn({
     *   select: { baseId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Fppa04CPMCreateManyAndReturnArgs>(args?: SelectSubset<T, Fppa04CPMCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fppa04CPM.
     * @param {Fppa04CPMDeleteArgs} args - Arguments to delete one Fppa04CPM.
     * @example
     * // Delete one Fppa04CPM
     * const Fppa04CPM = await prisma.fppa04CPM.delete({
     *   where: {
     *     // ... filter to delete one Fppa04CPM
     *   }
     * })
     * 
     */
    delete<T extends Fppa04CPMDeleteArgs>(args: SelectSubset<T, Fppa04CPMDeleteArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fppa04CPM.
     * @param {Fppa04CPMUpdateArgs} args - Arguments to update one Fppa04CPM.
     * @example
     * // Update one Fppa04CPM
     * const fppa04CPM = await prisma.fppa04CPM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Fppa04CPMUpdateArgs>(args: SelectSubset<T, Fppa04CPMUpdateArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fppa04CPMS.
     * @param {Fppa04CPMDeleteManyArgs} args - Arguments to filter Fppa04CPMS to delete.
     * @example
     * // Delete a few Fppa04CPMS
     * const { count } = await prisma.fppa04CPM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Fppa04CPMDeleteManyArgs>(args?: SelectSubset<T, Fppa04CPMDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fppa04CPMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04CPMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fppa04CPMS
     * const fppa04CPM = await prisma.fppa04CPM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Fppa04CPMUpdateManyArgs>(args: SelectSubset<T, Fppa04CPMUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fppa04CPMS and returns the data updated in the database.
     * @param {Fppa04CPMUpdateManyAndReturnArgs} args - Arguments to update many Fppa04CPMS.
     * @example
     * // Update many Fppa04CPMS
     * const fppa04CPM = await prisma.fppa04CPM.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fppa04CPMS and only return the `baseId`
     * const fppa04CPMWithBaseIdOnly = await prisma.fppa04CPM.updateManyAndReturn({
     *   select: { baseId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Fppa04CPMUpdateManyAndReturnArgs>(args: SelectSubset<T, Fppa04CPMUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fppa04CPM.
     * @param {Fppa04CPMUpsertArgs} args - Arguments to update or create a Fppa04CPM.
     * @example
     * // Update or create a Fppa04CPM
     * const fppa04CPM = await prisma.fppa04CPM.upsert({
     *   create: {
     *     // ... data to create a Fppa04CPM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fppa04CPM we want to update
     *   }
     * })
     */
    upsert<T extends Fppa04CPMUpsertArgs>(args: SelectSubset<T, Fppa04CPMUpsertArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fppa04CPMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04CPMCountArgs} args - Arguments to filter Fppa04CPMS to count.
     * @example
     * // Count the number of Fppa04CPMS
     * const count = await prisma.fppa04CPM.count({
     *   where: {
     *     // ... the filter for the Fppa04CPMS we want to count
     *   }
     * })
    **/
    count<T extends Fppa04CPMCountArgs>(
      args?: Subset<T, Fppa04CPMCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fppa04CPMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fppa04CPM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04CPMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fppa04CPMAggregateArgs>(args: Subset<T, Fppa04CPMAggregateArgs>): Prisma.PrismaPromise<GetFppa04CPMAggregateType<T>>

    /**
     * Group by Fppa04CPM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04CPMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fppa04CPMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fppa04CPMGroupByArgs['orderBy'] }
        : { orderBy?: Fppa04CPMGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fppa04CPMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFppa04CPMGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fppa04CPM model
   */
  readonly fields: Fppa04CPMFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fppa04CPM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Fppa04CPMClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    base<T extends Fppa04BaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Fppa04BaseDefaultArgs<ExtArgs>>): Prisma__Fppa04BaseClient<$Result.GetResult<Prisma.$Fppa04BasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Fppa04CPM$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Fppa04CPM$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adjustments<T extends Fppa04CPM$adjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Fppa04CPM$adjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fppa04CPM model
   */
  interface Fppa04CPMFieldRefs {
    readonly baseId: FieldRef<"Fppa04CPM", 'String'>
    readonly eventType: FieldRef<"Fppa04CPM", 'String'>
    readonly claimRefNumber: FieldRef<"Fppa04CPM", 'String'>
    readonly eventDescription: FieldRef<"Fppa04CPM", 'String'>
    readonly productionYear: FieldRef<"Fppa04CPM", 'Int'>
    readonly accidentDate: FieldRef<"Fppa04CPM", 'DateTime'>
    readonly reportedDate: FieldRef<"Fppa04CPM", 'DateTime'>
    readonly receivedDocDate: FieldRef<"Fppa04CPM", 'DateTime'>
    readonly company: FieldRef<"Fppa04CPM", 'String'>
    readonly factory: FieldRef<"Fppa04CPM", 'String'>
    readonly policyNumber: FieldRef<"Fppa04CPM", 'String'>
    readonly surveyorRefNumber: FieldRef<"Fppa04CPM", 'String'>
    readonly insurancePayout: FieldRef<"Fppa04CPM", 'Float'>
    readonly netAmount: FieldRef<"Fppa04CPM", 'Float'>
    readonly signatureFiles: FieldRef<"Fppa04CPM", 'String[]'>
    readonly createdAt: FieldRef<"Fppa04CPM", 'DateTime'>
    readonly updatedAt: FieldRef<"Fppa04CPM", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fppa04CPM findUnique
   */
  export type Fppa04CPMFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04CPM to fetch.
     */
    where: Fppa04CPMWhereUniqueInput
  }

  /**
   * Fppa04CPM findUniqueOrThrow
   */
  export type Fppa04CPMFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04CPM to fetch.
     */
    where: Fppa04CPMWhereUniqueInput
  }

  /**
   * Fppa04CPM findFirst
   */
  export type Fppa04CPMFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04CPM to fetch.
     */
    where?: Fppa04CPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04CPMS to fetch.
     */
    orderBy?: Fppa04CPMOrderByWithRelationInput | Fppa04CPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fppa04CPMS.
     */
    cursor?: Fppa04CPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04CPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04CPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fppa04CPMS.
     */
    distinct?: Fppa04CPMScalarFieldEnum | Fppa04CPMScalarFieldEnum[]
  }

  /**
   * Fppa04CPM findFirstOrThrow
   */
  export type Fppa04CPMFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04CPM to fetch.
     */
    where?: Fppa04CPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04CPMS to fetch.
     */
    orderBy?: Fppa04CPMOrderByWithRelationInput | Fppa04CPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fppa04CPMS.
     */
    cursor?: Fppa04CPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04CPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04CPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fppa04CPMS.
     */
    distinct?: Fppa04CPMScalarFieldEnum | Fppa04CPMScalarFieldEnum[]
  }

  /**
   * Fppa04CPM findMany
   */
  export type Fppa04CPMFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04CPMS to fetch.
     */
    where?: Fppa04CPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04CPMS to fetch.
     */
    orderBy?: Fppa04CPMOrderByWithRelationInput | Fppa04CPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fppa04CPMS.
     */
    cursor?: Fppa04CPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04CPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04CPMS.
     */
    skip?: number
    distinct?: Fppa04CPMScalarFieldEnum | Fppa04CPMScalarFieldEnum[]
  }

  /**
   * Fppa04CPM create
   */
  export type Fppa04CPMCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * The data needed to create a Fppa04CPM.
     */
    data: XOR<Fppa04CPMCreateInput, Fppa04CPMUncheckedCreateInput>
  }

  /**
   * Fppa04CPM createMany
   */
  export type Fppa04CPMCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fppa04CPMS.
     */
    data: Fppa04CPMCreateManyInput | Fppa04CPMCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fppa04CPM createManyAndReturn
   */
  export type Fppa04CPMCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * The data used to create many Fppa04CPMS.
     */
    data: Fppa04CPMCreateManyInput | Fppa04CPMCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fppa04CPM update
   */
  export type Fppa04CPMUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * The data needed to update a Fppa04CPM.
     */
    data: XOR<Fppa04CPMUpdateInput, Fppa04CPMUncheckedUpdateInput>
    /**
     * Choose, which Fppa04CPM to update.
     */
    where: Fppa04CPMWhereUniqueInput
  }

  /**
   * Fppa04CPM updateMany
   */
  export type Fppa04CPMUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fppa04CPMS.
     */
    data: XOR<Fppa04CPMUpdateManyMutationInput, Fppa04CPMUncheckedUpdateManyInput>
    /**
     * Filter which Fppa04CPMS to update
     */
    where?: Fppa04CPMWhereInput
    /**
     * Limit how many Fppa04CPMS to update.
     */
    limit?: number
  }

  /**
   * Fppa04CPM updateManyAndReturn
   */
  export type Fppa04CPMUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * The data used to update Fppa04CPMS.
     */
    data: XOR<Fppa04CPMUpdateManyMutationInput, Fppa04CPMUncheckedUpdateManyInput>
    /**
     * Filter which Fppa04CPMS to update
     */
    where?: Fppa04CPMWhereInput
    /**
     * Limit how many Fppa04CPMS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fppa04CPM upsert
   */
  export type Fppa04CPMUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * The filter to search for the Fppa04CPM to update in case it exists.
     */
    where: Fppa04CPMWhereUniqueInput
    /**
     * In case the Fppa04CPM found by the `where` argument doesn't exist, create a new Fppa04CPM with this data.
     */
    create: XOR<Fppa04CPMCreateInput, Fppa04CPMUncheckedCreateInput>
    /**
     * In case the Fppa04CPM was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Fppa04CPMUpdateInput, Fppa04CPMUncheckedUpdateInput>
  }

  /**
   * Fppa04CPM delete
   */
  export type Fppa04CPMDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
    /**
     * Filter which Fppa04CPM to delete.
     */
    where: Fppa04CPMWhereUniqueInput
  }

  /**
   * Fppa04CPM deleteMany
   */
  export type Fppa04CPMDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fppa04CPMS to delete
     */
    where?: Fppa04CPMWhereInput
    /**
     * Limit how many Fppa04CPMS to delete.
     */
    limit?: number
  }

  /**
   * Fppa04CPM.items
   */
  export type Fppa04CPM$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    where?: Fppa04ItemCPMWhereInput
    orderBy?: Fppa04ItemCPMOrderByWithRelationInput | Fppa04ItemCPMOrderByWithRelationInput[]
    cursor?: Fppa04ItemCPMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Fppa04ItemCPMScalarFieldEnum | Fppa04ItemCPMScalarFieldEnum[]
  }

  /**
   * Fppa04CPM.adjustments
   */
  export type Fppa04CPM$adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    where?: Fppa04AdjustmentCPMWhereInput
    orderBy?: Fppa04AdjustmentCPMOrderByWithRelationInput | Fppa04AdjustmentCPMOrderByWithRelationInput[]
    cursor?: Fppa04AdjustmentCPMWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Fppa04AdjustmentCPMScalarFieldEnum | Fppa04AdjustmentCPMScalarFieldEnum[]
  }

  /**
   * Fppa04CPM without action
   */
  export type Fppa04CPMDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04CPM
     */
    select?: Fppa04CPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04CPM
     */
    omit?: Fppa04CPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04CPMInclude<ExtArgs> | null
  }


  /**
   * Model Fppa04ItemCPM
   */

  export type AggregateFppa04ItemCPM = {
    _count: Fppa04ItemCPMCountAggregateOutputType | null
    _avg: Fppa04ItemCPMAvgAggregateOutputType | null
    _sum: Fppa04ItemCPMSumAggregateOutputType | null
    _min: Fppa04ItemCPMMinAggregateOutputType | null
    _max: Fppa04ItemCPMMaxAggregateOutputType | null
  }

  export type Fppa04ItemCPMAvgAggregateOutputType = {
    total: number | null
    exception: number | null
  }

  export type Fppa04ItemCPMSumAggregateOutputType = {
    total: number | null
    exception: number | null
  }

  export type Fppa04ItemCPMMinAggregateOutputType = {
    id: string | null
    baseId: string | null
    category: string | null
    description: string | null
    total: number | null
    exception: number | null
  }

  export type Fppa04ItemCPMMaxAggregateOutputType = {
    id: string | null
    baseId: string | null
    category: string | null
    description: string | null
    total: number | null
    exception: number | null
  }

  export type Fppa04ItemCPMCountAggregateOutputType = {
    id: number
    baseId: number
    category: number
    description: number
    total: number
    exception: number
    _all: number
  }


  export type Fppa04ItemCPMAvgAggregateInputType = {
    total?: true
    exception?: true
  }

  export type Fppa04ItemCPMSumAggregateInputType = {
    total?: true
    exception?: true
  }

  export type Fppa04ItemCPMMinAggregateInputType = {
    id?: true
    baseId?: true
    category?: true
    description?: true
    total?: true
    exception?: true
  }

  export type Fppa04ItemCPMMaxAggregateInputType = {
    id?: true
    baseId?: true
    category?: true
    description?: true
    total?: true
    exception?: true
  }

  export type Fppa04ItemCPMCountAggregateInputType = {
    id?: true
    baseId?: true
    category?: true
    description?: true
    total?: true
    exception?: true
    _all?: true
  }

  export type Fppa04ItemCPMAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fppa04ItemCPM to aggregate.
     */
    where?: Fppa04ItemCPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04ItemCPMS to fetch.
     */
    orderBy?: Fppa04ItemCPMOrderByWithRelationInput | Fppa04ItemCPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Fppa04ItemCPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04ItemCPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04ItemCPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fppa04ItemCPMS
    **/
    _count?: true | Fppa04ItemCPMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fppa04ItemCPMAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fppa04ItemCPMSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fppa04ItemCPMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fppa04ItemCPMMaxAggregateInputType
  }

  export type GetFppa04ItemCPMAggregateType<T extends Fppa04ItemCPMAggregateArgs> = {
        [P in keyof T & keyof AggregateFppa04ItemCPM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFppa04ItemCPM[P]>
      : GetScalarType<T[P], AggregateFppa04ItemCPM[P]>
  }




  export type Fppa04ItemCPMGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Fppa04ItemCPMWhereInput
    orderBy?: Fppa04ItemCPMOrderByWithAggregationInput | Fppa04ItemCPMOrderByWithAggregationInput[]
    by: Fppa04ItemCPMScalarFieldEnum[] | Fppa04ItemCPMScalarFieldEnum
    having?: Fppa04ItemCPMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fppa04ItemCPMCountAggregateInputType | true
    _avg?: Fppa04ItemCPMAvgAggregateInputType
    _sum?: Fppa04ItemCPMSumAggregateInputType
    _min?: Fppa04ItemCPMMinAggregateInputType
    _max?: Fppa04ItemCPMMaxAggregateInputType
  }

  export type Fppa04ItemCPMGroupByOutputType = {
    id: string
    baseId: string
    category: string
    description: string
    total: number
    exception: number
    _count: Fppa04ItemCPMCountAggregateOutputType | null
    _avg: Fppa04ItemCPMAvgAggregateOutputType | null
    _sum: Fppa04ItemCPMSumAggregateOutputType | null
    _min: Fppa04ItemCPMMinAggregateOutputType | null
    _max: Fppa04ItemCPMMaxAggregateOutputType | null
  }

  type GetFppa04ItemCPMGroupByPayload<T extends Fppa04ItemCPMGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fppa04ItemCPMGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fppa04ItemCPMGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fppa04ItemCPMGroupByOutputType[P]>
            : GetScalarType<T[P], Fppa04ItemCPMGroupByOutputType[P]>
        }
      >
    >


  export type Fppa04ItemCPMSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseId?: boolean
    category?: boolean
    description?: boolean
    total?: boolean
    exception?: boolean
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04ItemCPM"]>

  export type Fppa04ItemCPMSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseId?: boolean
    category?: boolean
    description?: boolean
    total?: boolean
    exception?: boolean
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04ItemCPM"]>

  export type Fppa04ItemCPMSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseId?: boolean
    category?: boolean
    description?: boolean
    total?: boolean
    exception?: boolean
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04ItemCPM"]>

  export type Fppa04ItemCPMSelectScalar = {
    id?: boolean
    baseId?: boolean
    category?: boolean
    description?: boolean
    total?: boolean
    exception?: boolean
  }

  export type Fppa04ItemCPMOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "baseId" | "category" | "description" | "total" | "exception", ExtArgs["result"]["fppa04ItemCPM"]>
  export type Fppa04ItemCPMInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }
  export type Fppa04ItemCPMIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }
  export type Fppa04ItemCPMIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }

  export type $Fppa04ItemCPMPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fppa04ItemCPM"
    objects: {
      variant: Prisma.$Fppa04CPMPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      baseId: string
      category: string
      description: string
      total: number
      exception: number
    }, ExtArgs["result"]["fppa04ItemCPM"]>
    composites: {}
  }

  type Fppa04ItemCPMGetPayload<S extends boolean | null | undefined | Fppa04ItemCPMDefaultArgs> = $Result.GetResult<Prisma.$Fppa04ItemCPMPayload, S>

  type Fppa04ItemCPMCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Fppa04ItemCPMFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Fppa04ItemCPMCountAggregateInputType | true
    }

  export interface Fppa04ItemCPMDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fppa04ItemCPM'], meta: { name: 'Fppa04ItemCPM' } }
    /**
     * Find zero or one Fppa04ItemCPM that matches the filter.
     * @param {Fppa04ItemCPMFindUniqueArgs} args - Arguments to find a Fppa04ItemCPM
     * @example
     * // Get one Fppa04ItemCPM
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Fppa04ItemCPMFindUniqueArgs>(args: SelectSubset<T, Fppa04ItemCPMFindUniqueArgs<ExtArgs>>): Prisma__Fppa04ItemCPMClient<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fppa04ItemCPM that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Fppa04ItemCPMFindUniqueOrThrowArgs} args - Arguments to find a Fppa04ItemCPM
     * @example
     * // Get one Fppa04ItemCPM
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Fppa04ItemCPMFindUniqueOrThrowArgs>(args: SelectSubset<T, Fppa04ItemCPMFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Fppa04ItemCPMClient<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fppa04ItemCPM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04ItemCPMFindFirstArgs} args - Arguments to find a Fppa04ItemCPM
     * @example
     * // Get one Fppa04ItemCPM
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Fppa04ItemCPMFindFirstArgs>(args?: SelectSubset<T, Fppa04ItemCPMFindFirstArgs<ExtArgs>>): Prisma__Fppa04ItemCPMClient<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fppa04ItemCPM that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04ItemCPMFindFirstOrThrowArgs} args - Arguments to find a Fppa04ItemCPM
     * @example
     * // Get one Fppa04ItemCPM
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Fppa04ItemCPMFindFirstOrThrowArgs>(args?: SelectSubset<T, Fppa04ItemCPMFindFirstOrThrowArgs<ExtArgs>>): Prisma__Fppa04ItemCPMClient<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fppa04ItemCPMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04ItemCPMFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fppa04ItemCPMS
     * const fppa04ItemCPMS = await prisma.fppa04ItemCPM.findMany()
     * 
     * // Get first 10 Fppa04ItemCPMS
     * const fppa04ItemCPMS = await prisma.fppa04ItemCPM.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fppa04ItemCPMWithIdOnly = await prisma.fppa04ItemCPM.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Fppa04ItemCPMFindManyArgs>(args?: SelectSubset<T, Fppa04ItemCPMFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fppa04ItemCPM.
     * @param {Fppa04ItemCPMCreateArgs} args - Arguments to create a Fppa04ItemCPM.
     * @example
     * // Create one Fppa04ItemCPM
     * const Fppa04ItemCPM = await prisma.fppa04ItemCPM.create({
     *   data: {
     *     // ... data to create a Fppa04ItemCPM
     *   }
     * })
     * 
     */
    create<T extends Fppa04ItemCPMCreateArgs>(args: SelectSubset<T, Fppa04ItemCPMCreateArgs<ExtArgs>>): Prisma__Fppa04ItemCPMClient<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fppa04ItemCPMS.
     * @param {Fppa04ItemCPMCreateManyArgs} args - Arguments to create many Fppa04ItemCPMS.
     * @example
     * // Create many Fppa04ItemCPMS
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Fppa04ItemCPMCreateManyArgs>(args?: SelectSubset<T, Fppa04ItemCPMCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fppa04ItemCPMS and returns the data saved in the database.
     * @param {Fppa04ItemCPMCreateManyAndReturnArgs} args - Arguments to create many Fppa04ItemCPMS.
     * @example
     * // Create many Fppa04ItemCPMS
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fppa04ItemCPMS and only return the `id`
     * const fppa04ItemCPMWithIdOnly = await prisma.fppa04ItemCPM.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Fppa04ItemCPMCreateManyAndReturnArgs>(args?: SelectSubset<T, Fppa04ItemCPMCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fppa04ItemCPM.
     * @param {Fppa04ItemCPMDeleteArgs} args - Arguments to delete one Fppa04ItemCPM.
     * @example
     * // Delete one Fppa04ItemCPM
     * const Fppa04ItemCPM = await prisma.fppa04ItemCPM.delete({
     *   where: {
     *     // ... filter to delete one Fppa04ItemCPM
     *   }
     * })
     * 
     */
    delete<T extends Fppa04ItemCPMDeleteArgs>(args: SelectSubset<T, Fppa04ItemCPMDeleteArgs<ExtArgs>>): Prisma__Fppa04ItemCPMClient<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fppa04ItemCPM.
     * @param {Fppa04ItemCPMUpdateArgs} args - Arguments to update one Fppa04ItemCPM.
     * @example
     * // Update one Fppa04ItemCPM
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Fppa04ItemCPMUpdateArgs>(args: SelectSubset<T, Fppa04ItemCPMUpdateArgs<ExtArgs>>): Prisma__Fppa04ItemCPMClient<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fppa04ItemCPMS.
     * @param {Fppa04ItemCPMDeleteManyArgs} args - Arguments to filter Fppa04ItemCPMS to delete.
     * @example
     * // Delete a few Fppa04ItemCPMS
     * const { count } = await prisma.fppa04ItemCPM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Fppa04ItemCPMDeleteManyArgs>(args?: SelectSubset<T, Fppa04ItemCPMDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fppa04ItemCPMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04ItemCPMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fppa04ItemCPMS
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Fppa04ItemCPMUpdateManyArgs>(args: SelectSubset<T, Fppa04ItemCPMUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fppa04ItemCPMS and returns the data updated in the database.
     * @param {Fppa04ItemCPMUpdateManyAndReturnArgs} args - Arguments to update many Fppa04ItemCPMS.
     * @example
     * // Update many Fppa04ItemCPMS
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fppa04ItemCPMS and only return the `id`
     * const fppa04ItemCPMWithIdOnly = await prisma.fppa04ItemCPM.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Fppa04ItemCPMUpdateManyAndReturnArgs>(args: SelectSubset<T, Fppa04ItemCPMUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fppa04ItemCPM.
     * @param {Fppa04ItemCPMUpsertArgs} args - Arguments to update or create a Fppa04ItemCPM.
     * @example
     * // Update or create a Fppa04ItemCPM
     * const fppa04ItemCPM = await prisma.fppa04ItemCPM.upsert({
     *   create: {
     *     // ... data to create a Fppa04ItemCPM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fppa04ItemCPM we want to update
     *   }
     * })
     */
    upsert<T extends Fppa04ItemCPMUpsertArgs>(args: SelectSubset<T, Fppa04ItemCPMUpsertArgs<ExtArgs>>): Prisma__Fppa04ItemCPMClient<$Result.GetResult<Prisma.$Fppa04ItemCPMPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fppa04ItemCPMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04ItemCPMCountArgs} args - Arguments to filter Fppa04ItemCPMS to count.
     * @example
     * // Count the number of Fppa04ItemCPMS
     * const count = await prisma.fppa04ItemCPM.count({
     *   where: {
     *     // ... the filter for the Fppa04ItemCPMS we want to count
     *   }
     * })
    **/
    count<T extends Fppa04ItemCPMCountArgs>(
      args?: Subset<T, Fppa04ItemCPMCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fppa04ItemCPMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fppa04ItemCPM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04ItemCPMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fppa04ItemCPMAggregateArgs>(args: Subset<T, Fppa04ItemCPMAggregateArgs>): Prisma.PrismaPromise<GetFppa04ItemCPMAggregateType<T>>

    /**
     * Group by Fppa04ItemCPM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04ItemCPMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fppa04ItemCPMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fppa04ItemCPMGroupByArgs['orderBy'] }
        : { orderBy?: Fppa04ItemCPMGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fppa04ItemCPMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFppa04ItemCPMGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fppa04ItemCPM model
   */
  readonly fields: Fppa04ItemCPMFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fppa04ItemCPM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Fppa04ItemCPMClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends Fppa04CPMDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Fppa04CPMDefaultArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fppa04ItemCPM model
   */
  interface Fppa04ItemCPMFieldRefs {
    readonly id: FieldRef<"Fppa04ItemCPM", 'String'>
    readonly baseId: FieldRef<"Fppa04ItemCPM", 'String'>
    readonly category: FieldRef<"Fppa04ItemCPM", 'String'>
    readonly description: FieldRef<"Fppa04ItemCPM", 'String'>
    readonly total: FieldRef<"Fppa04ItemCPM", 'Float'>
    readonly exception: FieldRef<"Fppa04ItemCPM", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Fppa04ItemCPM findUnique
   */
  export type Fppa04ItemCPMFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04ItemCPM to fetch.
     */
    where: Fppa04ItemCPMWhereUniqueInput
  }

  /**
   * Fppa04ItemCPM findUniqueOrThrow
   */
  export type Fppa04ItemCPMFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04ItemCPM to fetch.
     */
    where: Fppa04ItemCPMWhereUniqueInput
  }

  /**
   * Fppa04ItemCPM findFirst
   */
  export type Fppa04ItemCPMFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04ItemCPM to fetch.
     */
    where?: Fppa04ItemCPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04ItemCPMS to fetch.
     */
    orderBy?: Fppa04ItemCPMOrderByWithRelationInput | Fppa04ItemCPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fppa04ItemCPMS.
     */
    cursor?: Fppa04ItemCPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04ItemCPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04ItemCPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fppa04ItemCPMS.
     */
    distinct?: Fppa04ItemCPMScalarFieldEnum | Fppa04ItemCPMScalarFieldEnum[]
  }

  /**
   * Fppa04ItemCPM findFirstOrThrow
   */
  export type Fppa04ItemCPMFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04ItemCPM to fetch.
     */
    where?: Fppa04ItemCPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04ItemCPMS to fetch.
     */
    orderBy?: Fppa04ItemCPMOrderByWithRelationInput | Fppa04ItemCPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fppa04ItemCPMS.
     */
    cursor?: Fppa04ItemCPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04ItemCPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04ItemCPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fppa04ItemCPMS.
     */
    distinct?: Fppa04ItemCPMScalarFieldEnum | Fppa04ItemCPMScalarFieldEnum[]
  }

  /**
   * Fppa04ItemCPM findMany
   */
  export type Fppa04ItemCPMFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04ItemCPMS to fetch.
     */
    where?: Fppa04ItemCPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04ItemCPMS to fetch.
     */
    orderBy?: Fppa04ItemCPMOrderByWithRelationInput | Fppa04ItemCPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fppa04ItemCPMS.
     */
    cursor?: Fppa04ItemCPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04ItemCPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04ItemCPMS.
     */
    skip?: number
    distinct?: Fppa04ItemCPMScalarFieldEnum | Fppa04ItemCPMScalarFieldEnum[]
  }

  /**
   * Fppa04ItemCPM create
   */
  export type Fppa04ItemCPMCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * The data needed to create a Fppa04ItemCPM.
     */
    data: XOR<Fppa04ItemCPMCreateInput, Fppa04ItemCPMUncheckedCreateInput>
  }

  /**
   * Fppa04ItemCPM createMany
   */
  export type Fppa04ItemCPMCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fppa04ItemCPMS.
     */
    data: Fppa04ItemCPMCreateManyInput | Fppa04ItemCPMCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fppa04ItemCPM createManyAndReturn
   */
  export type Fppa04ItemCPMCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * The data used to create many Fppa04ItemCPMS.
     */
    data: Fppa04ItemCPMCreateManyInput | Fppa04ItemCPMCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fppa04ItemCPM update
   */
  export type Fppa04ItemCPMUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * The data needed to update a Fppa04ItemCPM.
     */
    data: XOR<Fppa04ItemCPMUpdateInput, Fppa04ItemCPMUncheckedUpdateInput>
    /**
     * Choose, which Fppa04ItemCPM to update.
     */
    where: Fppa04ItemCPMWhereUniqueInput
  }

  /**
   * Fppa04ItemCPM updateMany
   */
  export type Fppa04ItemCPMUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fppa04ItemCPMS.
     */
    data: XOR<Fppa04ItemCPMUpdateManyMutationInput, Fppa04ItemCPMUncheckedUpdateManyInput>
    /**
     * Filter which Fppa04ItemCPMS to update
     */
    where?: Fppa04ItemCPMWhereInput
    /**
     * Limit how many Fppa04ItemCPMS to update.
     */
    limit?: number
  }

  /**
   * Fppa04ItemCPM updateManyAndReturn
   */
  export type Fppa04ItemCPMUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * The data used to update Fppa04ItemCPMS.
     */
    data: XOR<Fppa04ItemCPMUpdateManyMutationInput, Fppa04ItemCPMUncheckedUpdateManyInput>
    /**
     * Filter which Fppa04ItemCPMS to update
     */
    where?: Fppa04ItemCPMWhereInput
    /**
     * Limit how many Fppa04ItemCPMS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fppa04ItemCPM upsert
   */
  export type Fppa04ItemCPMUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * The filter to search for the Fppa04ItemCPM to update in case it exists.
     */
    where: Fppa04ItemCPMWhereUniqueInput
    /**
     * In case the Fppa04ItemCPM found by the `where` argument doesn't exist, create a new Fppa04ItemCPM with this data.
     */
    create: XOR<Fppa04ItemCPMCreateInput, Fppa04ItemCPMUncheckedCreateInput>
    /**
     * In case the Fppa04ItemCPM was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Fppa04ItemCPMUpdateInput, Fppa04ItemCPMUncheckedUpdateInput>
  }

  /**
   * Fppa04ItemCPM delete
   */
  export type Fppa04ItemCPMDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
    /**
     * Filter which Fppa04ItemCPM to delete.
     */
    where: Fppa04ItemCPMWhereUniqueInput
  }

  /**
   * Fppa04ItemCPM deleteMany
   */
  export type Fppa04ItemCPMDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fppa04ItemCPMS to delete
     */
    where?: Fppa04ItemCPMWhereInput
    /**
     * Limit how many Fppa04ItemCPMS to delete.
     */
    limit?: number
  }

  /**
   * Fppa04ItemCPM without action
   */
  export type Fppa04ItemCPMDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04ItemCPM
     */
    select?: Fppa04ItemCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04ItemCPM
     */
    omit?: Fppa04ItemCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04ItemCPMInclude<ExtArgs> | null
  }


  /**
   * Model Fppa04AdjustmentCPM
   */

  export type AggregateFppa04AdjustmentCPM = {
    _count: Fppa04AdjustmentCPMCountAggregateOutputType | null
    _avg: Fppa04AdjustmentCPMAvgAggregateOutputType | null
    _sum: Fppa04AdjustmentCPMSumAggregateOutputType | null
    _min: Fppa04AdjustmentCPMMinAggregateOutputType | null
    _max: Fppa04AdjustmentCPMMaxAggregateOutputType | null
  }

  export type Fppa04AdjustmentCPMAvgAggregateOutputType = {
    amount: number | null
  }

  export type Fppa04AdjustmentCPMSumAggregateOutputType = {
    amount: number | null
  }

  export type Fppa04AdjustmentCPMMinAggregateOutputType = {
    id: string | null
    baseId: string | null
    type: string | null
    description: string | null
    amount: number | null
  }

  export type Fppa04AdjustmentCPMMaxAggregateOutputType = {
    id: string | null
    baseId: string | null
    type: string | null
    description: string | null
    amount: number | null
  }

  export type Fppa04AdjustmentCPMCountAggregateOutputType = {
    id: number
    baseId: number
    type: number
    description: number
    amount: number
    _all: number
  }


  export type Fppa04AdjustmentCPMAvgAggregateInputType = {
    amount?: true
  }

  export type Fppa04AdjustmentCPMSumAggregateInputType = {
    amount?: true
  }

  export type Fppa04AdjustmentCPMMinAggregateInputType = {
    id?: true
    baseId?: true
    type?: true
    description?: true
    amount?: true
  }

  export type Fppa04AdjustmentCPMMaxAggregateInputType = {
    id?: true
    baseId?: true
    type?: true
    description?: true
    amount?: true
  }

  export type Fppa04AdjustmentCPMCountAggregateInputType = {
    id?: true
    baseId?: true
    type?: true
    description?: true
    amount?: true
    _all?: true
  }

  export type Fppa04AdjustmentCPMAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fppa04AdjustmentCPM to aggregate.
     */
    where?: Fppa04AdjustmentCPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04AdjustmentCPMS to fetch.
     */
    orderBy?: Fppa04AdjustmentCPMOrderByWithRelationInput | Fppa04AdjustmentCPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Fppa04AdjustmentCPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04AdjustmentCPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04AdjustmentCPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fppa04AdjustmentCPMS
    **/
    _count?: true | Fppa04AdjustmentCPMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fppa04AdjustmentCPMAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fppa04AdjustmentCPMSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fppa04AdjustmentCPMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fppa04AdjustmentCPMMaxAggregateInputType
  }

  export type GetFppa04AdjustmentCPMAggregateType<T extends Fppa04AdjustmentCPMAggregateArgs> = {
        [P in keyof T & keyof AggregateFppa04AdjustmentCPM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFppa04AdjustmentCPM[P]>
      : GetScalarType<T[P], AggregateFppa04AdjustmentCPM[P]>
  }




  export type Fppa04AdjustmentCPMGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Fppa04AdjustmentCPMWhereInput
    orderBy?: Fppa04AdjustmentCPMOrderByWithAggregationInput | Fppa04AdjustmentCPMOrderByWithAggregationInput[]
    by: Fppa04AdjustmentCPMScalarFieldEnum[] | Fppa04AdjustmentCPMScalarFieldEnum
    having?: Fppa04AdjustmentCPMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fppa04AdjustmentCPMCountAggregateInputType | true
    _avg?: Fppa04AdjustmentCPMAvgAggregateInputType
    _sum?: Fppa04AdjustmentCPMSumAggregateInputType
    _min?: Fppa04AdjustmentCPMMinAggregateInputType
    _max?: Fppa04AdjustmentCPMMaxAggregateInputType
  }

  export type Fppa04AdjustmentCPMGroupByOutputType = {
    id: string
    baseId: string
    type: string
    description: string
    amount: number
    _count: Fppa04AdjustmentCPMCountAggregateOutputType | null
    _avg: Fppa04AdjustmentCPMAvgAggregateOutputType | null
    _sum: Fppa04AdjustmentCPMSumAggregateOutputType | null
    _min: Fppa04AdjustmentCPMMinAggregateOutputType | null
    _max: Fppa04AdjustmentCPMMaxAggregateOutputType | null
  }

  type GetFppa04AdjustmentCPMGroupByPayload<T extends Fppa04AdjustmentCPMGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fppa04AdjustmentCPMGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fppa04AdjustmentCPMGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fppa04AdjustmentCPMGroupByOutputType[P]>
            : GetScalarType<T[P], Fppa04AdjustmentCPMGroupByOutputType[P]>
        }
      >
    >


  export type Fppa04AdjustmentCPMSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04AdjustmentCPM"]>

  export type Fppa04AdjustmentCPMSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04AdjustmentCPM"]>

  export type Fppa04AdjustmentCPMSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    baseId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fppa04AdjustmentCPM"]>

  export type Fppa04AdjustmentCPMSelectScalar = {
    id?: boolean
    baseId?: boolean
    type?: boolean
    description?: boolean
    amount?: boolean
  }

  export type Fppa04AdjustmentCPMOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "baseId" | "type" | "description" | "amount", ExtArgs["result"]["fppa04AdjustmentCPM"]>
  export type Fppa04AdjustmentCPMInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }
  export type Fppa04AdjustmentCPMIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }
  export type Fppa04AdjustmentCPMIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | Fppa04CPMDefaultArgs<ExtArgs>
  }

  export type $Fppa04AdjustmentCPMPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fppa04AdjustmentCPM"
    objects: {
      variant: Prisma.$Fppa04CPMPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      baseId: string
      type: string
      description: string
      amount: number
    }, ExtArgs["result"]["fppa04AdjustmentCPM"]>
    composites: {}
  }

  type Fppa04AdjustmentCPMGetPayload<S extends boolean | null | undefined | Fppa04AdjustmentCPMDefaultArgs> = $Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload, S>

  type Fppa04AdjustmentCPMCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Fppa04AdjustmentCPMFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Fppa04AdjustmentCPMCountAggregateInputType | true
    }

  export interface Fppa04AdjustmentCPMDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fppa04AdjustmentCPM'], meta: { name: 'Fppa04AdjustmentCPM' } }
    /**
     * Find zero or one Fppa04AdjustmentCPM that matches the filter.
     * @param {Fppa04AdjustmentCPMFindUniqueArgs} args - Arguments to find a Fppa04AdjustmentCPM
     * @example
     * // Get one Fppa04AdjustmentCPM
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Fppa04AdjustmentCPMFindUniqueArgs>(args: SelectSubset<T, Fppa04AdjustmentCPMFindUniqueArgs<ExtArgs>>): Prisma__Fppa04AdjustmentCPMClient<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fppa04AdjustmentCPM that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Fppa04AdjustmentCPMFindUniqueOrThrowArgs} args - Arguments to find a Fppa04AdjustmentCPM
     * @example
     * // Get one Fppa04AdjustmentCPM
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Fppa04AdjustmentCPMFindUniqueOrThrowArgs>(args: SelectSubset<T, Fppa04AdjustmentCPMFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Fppa04AdjustmentCPMClient<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fppa04AdjustmentCPM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04AdjustmentCPMFindFirstArgs} args - Arguments to find a Fppa04AdjustmentCPM
     * @example
     * // Get one Fppa04AdjustmentCPM
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Fppa04AdjustmentCPMFindFirstArgs>(args?: SelectSubset<T, Fppa04AdjustmentCPMFindFirstArgs<ExtArgs>>): Prisma__Fppa04AdjustmentCPMClient<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fppa04AdjustmentCPM that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04AdjustmentCPMFindFirstOrThrowArgs} args - Arguments to find a Fppa04AdjustmentCPM
     * @example
     * // Get one Fppa04AdjustmentCPM
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Fppa04AdjustmentCPMFindFirstOrThrowArgs>(args?: SelectSubset<T, Fppa04AdjustmentCPMFindFirstOrThrowArgs<ExtArgs>>): Prisma__Fppa04AdjustmentCPMClient<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fppa04AdjustmentCPMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04AdjustmentCPMFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fppa04AdjustmentCPMS
     * const fppa04AdjustmentCPMS = await prisma.fppa04AdjustmentCPM.findMany()
     * 
     * // Get first 10 Fppa04AdjustmentCPMS
     * const fppa04AdjustmentCPMS = await prisma.fppa04AdjustmentCPM.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fppa04AdjustmentCPMWithIdOnly = await prisma.fppa04AdjustmentCPM.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Fppa04AdjustmentCPMFindManyArgs>(args?: SelectSubset<T, Fppa04AdjustmentCPMFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fppa04AdjustmentCPM.
     * @param {Fppa04AdjustmentCPMCreateArgs} args - Arguments to create a Fppa04AdjustmentCPM.
     * @example
     * // Create one Fppa04AdjustmentCPM
     * const Fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.create({
     *   data: {
     *     // ... data to create a Fppa04AdjustmentCPM
     *   }
     * })
     * 
     */
    create<T extends Fppa04AdjustmentCPMCreateArgs>(args: SelectSubset<T, Fppa04AdjustmentCPMCreateArgs<ExtArgs>>): Prisma__Fppa04AdjustmentCPMClient<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fppa04AdjustmentCPMS.
     * @param {Fppa04AdjustmentCPMCreateManyArgs} args - Arguments to create many Fppa04AdjustmentCPMS.
     * @example
     * // Create many Fppa04AdjustmentCPMS
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Fppa04AdjustmentCPMCreateManyArgs>(args?: SelectSubset<T, Fppa04AdjustmentCPMCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fppa04AdjustmentCPMS and returns the data saved in the database.
     * @param {Fppa04AdjustmentCPMCreateManyAndReturnArgs} args - Arguments to create many Fppa04AdjustmentCPMS.
     * @example
     * // Create many Fppa04AdjustmentCPMS
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fppa04AdjustmentCPMS and only return the `id`
     * const fppa04AdjustmentCPMWithIdOnly = await prisma.fppa04AdjustmentCPM.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Fppa04AdjustmentCPMCreateManyAndReturnArgs>(args?: SelectSubset<T, Fppa04AdjustmentCPMCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fppa04AdjustmentCPM.
     * @param {Fppa04AdjustmentCPMDeleteArgs} args - Arguments to delete one Fppa04AdjustmentCPM.
     * @example
     * // Delete one Fppa04AdjustmentCPM
     * const Fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.delete({
     *   where: {
     *     // ... filter to delete one Fppa04AdjustmentCPM
     *   }
     * })
     * 
     */
    delete<T extends Fppa04AdjustmentCPMDeleteArgs>(args: SelectSubset<T, Fppa04AdjustmentCPMDeleteArgs<ExtArgs>>): Prisma__Fppa04AdjustmentCPMClient<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fppa04AdjustmentCPM.
     * @param {Fppa04AdjustmentCPMUpdateArgs} args - Arguments to update one Fppa04AdjustmentCPM.
     * @example
     * // Update one Fppa04AdjustmentCPM
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Fppa04AdjustmentCPMUpdateArgs>(args: SelectSubset<T, Fppa04AdjustmentCPMUpdateArgs<ExtArgs>>): Prisma__Fppa04AdjustmentCPMClient<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fppa04AdjustmentCPMS.
     * @param {Fppa04AdjustmentCPMDeleteManyArgs} args - Arguments to filter Fppa04AdjustmentCPMS to delete.
     * @example
     * // Delete a few Fppa04AdjustmentCPMS
     * const { count } = await prisma.fppa04AdjustmentCPM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Fppa04AdjustmentCPMDeleteManyArgs>(args?: SelectSubset<T, Fppa04AdjustmentCPMDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fppa04AdjustmentCPMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04AdjustmentCPMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fppa04AdjustmentCPMS
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Fppa04AdjustmentCPMUpdateManyArgs>(args: SelectSubset<T, Fppa04AdjustmentCPMUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fppa04AdjustmentCPMS and returns the data updated in the database.
     * @param {Fppa04AdjustmentCPMUpdateManyAndReturnArgs} args - Arguments to update many Fppa04AdjustmentCPMS.
     * @example
     * // Update many Fppa04AdjustmentCPMS
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fppa04AdjustmentCPMS and only return the `id`
     * const fppa04AdjustmentCPMWithIdOnly = await prisma.fppa04AdjustmentCPM.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Fppa04AdjustmentCPMUpdateManyAndReturnArgs>(args: SelectSubset<T, Fppa04AdjustmentCPMUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fppa04AdjustmentCPM.
     * @param {Fppa04AdjustmentCPMUpsertArgs} args - Arguments to update or create a Fppa04AdjustmentCPM.
     * @example
     * // Update or create a Fppa04AdjustmentCPM
     * const fppa04AdjustmentCPM = await prisma.fppa04AdjustmentCPM.upsert({
     *   create: {
     *     // ... data to create a Fppa04AdjustmentCPM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fppa04AdjustmentCPM we want to update
     *   }
     * })
     */
    upsert<T extends Fppa04AdjustmentCPMUpsertArgs>(args: SelectSubset<T, Fppa04AdjustmentCPMUpsertArgs<ExtArgs>>): Prisma__Fppa04AdjustmentCPMClient<$Result.GetResult<Prisma.$Fppa04AdjustmentCPMPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fppa04AdjustmentCPMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04AdjustmentCPMCountArgs} args - Arguments to filter Fppa04AdjustmentCPMS to count.
     * @example
     * // Count the number of Fppa04AdjustmentCPMS
     * const count = await prisma.fppa04AdjustmentCPM.count({
     *   where: {
     *     // ... the filter for the Fppa04AdjustmentCPMS we want to count
     *   }
     * })
    **/
    count<T extends Fppa04AdjustmentCPMCountArgs>(
      args?: Subset<T, Fppa04AdjustmentCPMCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fppa04AdjustmentCPMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fppa04AdjustmentCPM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04AdjustmentCPMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fppa04AdjustmentCPMAggregateArgs>(args: Subset<T, Fppa04AdjustmentCPMAggregateArgs>): Prisma.PrismaPromise<GetFppa04AdjustmentCPMAggregateType<T>>

    /**
     * Group by Fppa04AdjustmentCPM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fppa04AdjustmentCPMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fppa04AdjustmentCPMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fppa04AdjustmentCPMGroupByArgs['orderBy'] }
        : { orderBy?: Fppa04AdjustmentCPMGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fppa04AdjustmentCPMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFppa04AdjustmentCPMGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fppa04AdjustmentCPM model
   */
  readonly fields: Fppa04AdjustmentCPMFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fppa04AdjustmentCPM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Fppa04AdjustmentCPMClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends Fppa04CPMDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Fppa04CPMDefaultArgs<ExtArgs>>): Prisma__Fppa04CPMClient<$Result.GetResult<Prisma.$Fppa04CPMPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fppa04AdjustmentCPM model
   */
  interface Fppa04AdjustmentCPMFieldRefs {
    readonly id: FieldRef<"Fppa04AdjustmentCPM", 'String'>
    readonly baseId: FieldRef<"Fppa04AdjustmentCPM", 'String'>
    readonly type: FieldRef<"Fppa04AdjustmentCPM", 'String'>
    readonly description: FieldRef<"Fppa04AdjustmentCPM", 'String'>
    readonly amount: FieldRef<"Fppa04AdjustmentCPM", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Fppa04AdjustmentCPM findUnique
   */
  export type Fppa04AdjustmentCPMFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04AdjustmentCPM to fetch.
     */
    where: Fppa04AdjustmentCPMWhereUniqueInput
  }

  /**
   * Fppa04AdjustmentCPM findUniqueOrThrow
   */
  export type Fppa04AdjustmentCPMFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04AdjustmentCPM to fetch.
     */
    where: Fppa04AdjustmentCPMWhereUniqueInput
  }

  /**
   * Fppa04AdjustmentCPM findFirst
   */
  export type Fppa04AdjustmentCPMFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04AdjustmentCPM to fetch.
     */
    where?: Fppa04AdjustmentCPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04AdjustmentCPMS to fetch.
     */
    orderBy?: Fppa04AdjustmentCPMOrderByWithRelationInput | Fppa04AdjustmentCPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fppa04AdjustmentCPMS.
     */
    cursor?: Fppa04AdjustmentCPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04AdjustmentCPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04AdjustmentCPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fppa04AdjustmentCPMS.
     */
    distinct?: Fppa04AdjustmentCPMScalarFieldEnum | Fppa04AdjustmentCPMScalarFieldEnum[]
  }

  /**
   * Fppa04AdjustmentCPM findFirstOrThrow
   */
  export type Fppa04AdjustmentCPMFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04AdjustmentCPM to fetch.
     */
    where?: Fppa04AdjustmentCPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04AdjustmentCPMS to fetch.
     */
    orderBy?: Fppa04AdjustmentCPMOrderByWithRelationInput | Fppa04AdjustmentCPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fppa04AdjustmentCPMS.
     */
    cursor?: Fppa04AdjustmentCPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04AdjustmentCPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04AdjustmentCPMS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fppa04AdjustmentCPMS.
     */
    distinct?: Fppa04AdjustmentCPMScalarFieldEnum | Fppa04AdjustmentCPMScalarFieldEnum[]
  }

  /**
   * Fppa04AdjustmentCPM findMany
   */
  export type Fppa04AdjustmentCPMFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * Filter, which Fppa04AdjustmentCPMS to fetch.
     */
    where?: Fppa04AdjustmentCPMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fppa04AdjustmentCPMS to fetch.
     */
    orderBy?: Fppa04AdjustmentCPMOrderByWithRelationInput | Fppa04AdjustmentCPMOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fppa04AdjustmentCPMS.
     */
    cursor?: Fppa04AdjustmentCPMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fppa04AdjustmentCPMS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fppa04AdjustmentCPMS.
     */
    skip?: number
    distinct?: Fppa04AdjustmentCPMScalarFieldEnum | Fppa04AdjustmentCPMScalarFieldEnum[]
  }

  /**
   * Fppa04AdjustmentCPM create
   */
  export type Fppa04AdjustmentCPMCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * The data needed to create a Fppa04AdjustmentCPM.
     */
    data: XOR<Fppa04AdjustmentCPMCreateInput, Fppa04AdjustmentCPMUncheckedCreateInput>
  }

  /**
   * Fppa04AdjustmentCPM createMany
   */
  export type Fppa04AdjustmentCPMCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fppa04AdjustmentCPMS.
     */
    data: Fppa04AdjustmentCPMCreateManyInput | Fppa04AdjustmentCPMCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fppa04AdjustmentCPM createManyAndReturn
   */
  export type Fppa04AdjustmentCPMCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * The data used to create many Fppa04AdjustmentCPMS.
     */
    data: Fppa04AdjustmentCPMCreateManyInput | Fppa04AdjustmentCPMCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fppa04AdjustmentCPM update
   */
  export type Fppa04AdjustmentCPMUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * The data needed to update a Fppa04AdjustmentCPM.
     */
    data: XOR<Fppa04AdjustmentCPMUpdateInput, Fppa04AdjustmentCPMUncheckedUpdateInput>
    /**
     * Choose, which Fppa04AdjustmentCPM to update.
     */
    where: Fppa04AdjustmentCPMWhereUniqueInput
  }

  /**
   * Fppa04AdjustmentCPM updateMany
   */
  export type Fppa04AdjustmentCPMUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fppa04AdjustmentCPMS.
     */
    data: XOR<Fppa04AdjustmentCPMUpdateManyMutationInput, Fppa04AdjustmentCPMUncheckedUpdateManyInput>
    /**
     * Filter which Fppa04AdjustmentCPMS to update
     */
    where?: Fppa04AdjustmentCPMWhereInput
    /**
     * Limit how many Fppa04AdjustmentCPMS to update.
     */
    limit?: number
  }

  /**
   * Fppa04AdjustmentCPM updateManyAndReturn
   */
  export type Fppa04AdjustmentCPMUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * The data used to update Fppa04AdjustmentCPMS.
     */
    data: XOR<Fppa04AdjustmentCPMUpdateManyMutationInput, Fppa04AdjustmentCPMUncheckedUpdateManyInput>
    /**
     * Filter which Fppa04AdjustmentCPMS to update
     */
    where?: Fppa04AdjustmentCPMWhereInput
    /**
     * Limit how many Fppa04AdjustmentCPMS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fppa04AdjustmentCPM upsert
   */
  export type Fppa04AdjustmentCPMUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * The filter to search for the Fppa04AdjustmentCPM to update in case it exists.
     */
    where: Fppa04AdjustmentCPMWhereUniqueInput
    /**
     * In case the Fppa04AdjustmentCPM found by the `where` argument doesn't exist, create a new Fppa04AdjustmentCPM with this data.
     */
    create: XOR<Fppa04AdjustmentCPMCreateInput, Fppa04AdjustmentCPMUncheckedCreateInput>
    /**
     * In case the Fppa04AdjustmentCPM was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Fppa04AdjustmentCPMUpdateInput, Fppa04AdjustmentCPMUncheckedUpdateInput>
  }

  /**
   * Fppa04AdjustmentCPM delete
   */
  export type Fppa04AdjustmentCPMDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
    /**
     * Filter which Fppa04AdjustmentCPM to delete.
     */
    where: Fppa04AdjustmentCPMWhereUniqueInput
  }

  /**
   * Fppa04AdjustmentCPM deleteMany
   */
  export type Fppa04AdjustmentCPMDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fppa04AdjustmentCPMS to delete
     */
    where?: Fppa04AdjustmentCPMWhereInput
    /**
     * Limit how many Fppa04AdjustmentCPMS to delete.
     */
    limit?: number
  }

  /**
   * Fppa04AdjustmentCPM without action
   */
  export type Fppa04AdjustmentCPMDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fppa04AdjustmentCPM
     */
    select?: Fppa04AdjustmentCPMSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fppa04AdjustmentCPM
     */
    omit?: Fppa04AdjustmentCPMOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Fppa04AdjustmentCPMInclude<ExtArgs> | null
  }


  /**
   * Model ClaimHistory
   */

  export type AggregateClaimHistory = {
    _count: ClaimHistoryCountAggregateOutputType | null
    _min: ClaimHistoryMinAggregateOutputType | null
    _max: ClaimHistoryMaxAggregateOutputType | null
  }

  export type ClaimHistoryMinAggregateOutputType = {
    id: string | null
    claimId: string | null
    status: $Enums.ClaimStatus | null
    createdAt: Date | null
  }

  export type ClaimHistoryMaxAggregateOutputType = {
    id: string | null
    claimId: string | null
    status: $Enums.ClaimStatus | null
    createdAt: Date | null
  }

  export type ClaimHistoryCountAggregateOutputType = {
    id: number
    claimId: number
    status: number
    createdAt: number
    _all: number
  }


  export type ClaimHistoryMinAggregateInputType = {
    id?: true
    claimId?: true
    status?: true
    createdAt?: true
  }

  export type ClaimHistoryMaxAggregateInputType = {
    id?: true
    claimId?: true
    status?: true
    createdAt?: true
  }

  export type ClaimHistoryCountAggregateInputType = {
    id?: true
    claimId?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ClaimHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimHistory to aggregate.
     */
    where?: ClaimHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimHistories to fetch.
     */
    orderBy?: ClaimHistoryOrderByWithRelationInput | ClaimHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClaimHistories
    **/
    _count?: true | ClaimHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimHistoryMaxAggregateInputType
  }

  export type GetClaimHistoryAggregateType<T extends ClaimHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateClaimHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaimHistory[P]>
      : GetScalarType<T[P], AggregateClaimHistory[P]>
  }




  export type ClaimHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimHistoryWhereInput
    orderBy?: ClaimHistoryOrderByWithAggregationInput | ClaimHistoryOrderByWithAggregationInput[]
    by: ClaimHistoryScalarFieldEnum[] | ClaimHistoryScalarFieldEnum
    having?: ClaimHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimHistoryCountAggregateInputType | true
    _min?: ClaimHistoryMinAggregateInputType
    _max?: ClaimHistoryMaxAggregateInputType
  }

  export type ClaimHistoryGroupByOutputType = {
    id: string
    claimId: string
    status: $Enums.ClaimStatus
    createdAt: Date
    _count: ClaimHistoryCountAggregateOutputType | null
    _min: ClaimHistoryMinAggregateOutputType | null
    _max: ClaimHistoryMaxAggregateOutputType | null
  }

  type GetClaimHistoryGroupByPayload<T extends ClaimHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ClaimHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    status?: boolean
    createdAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claimHistory"]>

  export type ClaimHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    status?: boolean
    createdAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claimHistory"]>

  export type ClaimHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claimId?: boolean
    status?: boolean
    createdAt?: boolean
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claimHistory"]>

  export type ClaimHistorySelectScalar = {
    id?: boolean
    claimId?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ClaimHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claimId" | "status" | "createdAt", ExtArgs["result"]["claimHistory"]>
  export type ClaimHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type ClaimHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }
  export type ClaimHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claim?: boolean | ClaimDefaultArgs<ExtArgs>
  }

  export type $ClaimHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClaimHistory"
    objects: {
      claim: Prisma.$ClaimPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claimId: string
      status: $Enums.ClaimStatus
      createdAt: Date
    }, ExtArgs["result"]["claimHistory"]>
    composites: {}
  }

  type ClaimHistoryGetPayload<S extends boolean | null | undefined | ClaimHistoryDefaultArgs> = $Result.GetResult<Prisma.$ClaimHistoryPayload, S>

  type ClaimHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClaimHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClaimHistoryCountAggregateInputType | true
    }

  export interface ClaimHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClaimHistory'], meta: { name: 'ClaimHistory' } }
    /**
     * Find zero or one ClaimHistory that matches the filter.
     * @param {ClaimHistoryFindUniqueArgs} args - Arguments to find a ClaimHistory
     * @example
     * // Get one ClaimHistory
     * const claimHistory = await prisma.claimHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimHistoryFindUniqueArgs>(args: SelectSubset<T, ClaimHistoryFindUniqueArgs<ExtArgs>>): Prisma__ClaimHistoryClient<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClaimHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClaimHistoryFindUniqueOrThrowArgs} args - Arguments to find a ClaimHistory
     * @example
     * // Get one ClaimHistory
     * const claimHistory = await prisma.claimHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimHistoryClient<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClaimHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimHistoryFindFirstArgs} args - Arguments to find a ClaimHistory
     * @example
     * // Get one ClaimHistory
     * const claimHistory = await prisma.claimHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimHistoryFindFirstArgs>(args?: SelectSubset<T, ClaimHistoryFindFirstArgs<ExtArgs>>): Prisma__ClaimHistoryClient<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClaimHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimHistoryFindFirstOrThrowArgs} args - Arguments to find a ClaimHistory
     * @example
     * // Get one ClaimHistory
     * const claimHistory = await prisma.claimHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimHistoryClient<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClaimHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClaimHistories
     * const claimHistories = await prisma.claimHistory.findMany()
     * 
     * // Get first 10 ClaimHistories
     * const claimHistories = await prisma.claimHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimHistoryWithIdOnly = await prisma.claimHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimHistoryFindManyArgs>(args?: SelectSubset<T, ClaimHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClaimHistory.
     * @param {ClaimHistoryCreateArgs} args - Arguments to create a ClaimHistory.
     * @example
     * // Create one ClaimHistory
     * const ClaimHistory = await prisma.claimHistory.create({
     *   data: {
     *     // ... data to create a ClaimHistory
     *   }
     * })
     * 
     */
    create<T extends ClaimHistoryCreateArgs>(args: SelectSubset<T, ClaimHistoryCreateArgs<ExtArgs>>): Prisma__ClaimHistoryClient<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClaimHistories.
     * @param {ClaimHistoryCreateManyArgs} args - Arguments to create many ClaimHistories.
     * @example
     * // Create many ClaimHistories
     * const claimHistory = await prisma.claimHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimHistoryCreateManyArgs>(args?: SelectSubset<T, ClaimHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClaimHistories and returns the data saved in the database.
     * @param {ClaimHistoryCreateManyAndReturnArgs} args - Arguments to create many ClaimHistories.
     * @example
     * // Create many ClaimHistories
     * const claimHistory = await prisma.claimHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClaimHistories and only return the `id`
     * const claimHistoryWithIdOnly = await prisma.claimHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClaimHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ClaimHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClaimHistory.
     * @param {ClaimHistoryDeleteArgs} args - Arguments to delete one ClaimHistory.
     * @example
     * // Delete one ClaimHistory
     * const ClaimHistory = await prisma.claimHistory.delete({
     *   where: {
     *     // ... filter to delete one ClaimHistory
     *   }
     * })
     * 
     */
    delete<T extends ClaimHistoryDeleteArgs>(args: SelectSubset<T, ClaimHistoryDeleteArgs<ExtArgs>>): Prisma__ClaimHistoryClient<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClaimHistory.
     * @param {ClaimHistoryUpdateArgs} args - Arguments to update one ClaimHistory.
     * @example
     * // Update one ClaimHistory
     * const claimHistory = await prisma.claimHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimHistoryUpdateArgs>(args: SelectSubset<T, ClaimHistoryUpdateArgs<ExtArgs>>): Prisma__ClaimHistoryClient<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClaimHistories.
     * @param {ClaimHistoryDeleteManyArgs} args - Arguments to filter ClaimHistories to delete.
     * @example
     * // Delete a few ClaimHistories
     * const { count } = await prisma.claimHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimHistoryDeleteManyArgs>(args?: SelectSubset<T, ClaimHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClaimHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClaimHistories
     * const claimHistory = await prisma.claimHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimHistoryUpdateManyArgs>(args: SelectSubset<T, ClaimHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClaimHistories and returns the data updated in the database.
     * @param {ClaimHistoryUpdateManyAndReturnArgs} args - Arguments to update many ClaimHistories.
     * @example
     * // Update many ClaimHistories
     * const claimHistory = await prisma.claimHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClaimHistories and only return the `id`
     * const claimHistoryWithIdOnly = await prisma.claimHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClaimHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ClaimHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClaimHistory.
     * @param {ClaimHistoryUpsertArgs} args - Arguments to update or create a ClaimHistory.
     * @example
     * // Update or create a ClaimHistory
     * const claimHistory = await prisma.claimHistory.upsert({
     *   create: {
     *     // ... data to create a ClaimHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClaimHistory we want to update
     *   }
     * })
     */
    upsert<T extends ClaimHistoryUpsertArgs>(args: SelectSubset<T, ClaimHistoryUpsertArgs<ExtArgs>>): Prisma__ClaimHistoryClient<$Result.GetResult<Prisma.$ClaimHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClaimHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimHistoryCountArgs} args - Arguments to filter ClaimHistories to count.
     * @example
     * // Count the number of ClaimHistories
     * const count = await prisma.claimHistory.count({
     *   where: {
     *     // ... the filter for the ClaimHistories we want to count
     *   }
     * })
    **/
    count<T extends ClaimHistoryCountArgs>(
      args?: Subset<T, ClaimHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClaimHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimHistoryAggregateArgs>(args: Subset<T, ClaimHistoryAggregateArgs>): Prisma.PrismaPromise<GetClaimHistoryAggregateType<T>>

    /**
     * Group by ClaimHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ClaimHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClaimHistory model
   */
  readonly fields: ClaimHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClaimHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    claim<T extends ClaimDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClaimDefaultArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClaimHistory model
   */
  interface ClaimHistoryFieldRefs {
    readonly id: FieldRef<"ClaimHistory", 'String'>
    readonly claimId: FieldRef<"ClaimHistory", 'String'>
    readonly status: FieldRef<"ClaimHistory", 'ClaimStatus'>
    readonly createdAt: FieldRef<"ClaimHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClaimHistory findUnique
   */
  export type ClaimHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ClaimHistory to fetch.
     */
    where: ClaimHistoryWhereUniqueInput
  }

  /**
   * ClaimHistory findUniqueOrThrow
   */
  export type ClaimHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ClaimHistory to fetch.
     */
    where: ClaimHistoryWhereUniqueInput
  }

  /**
   * ClaimHistory findFirst
   */
  export type ClaimHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ClaimHistory to fetch.
     */
    where?: ClaimHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimHistories to fetch.
     */
    orderBy?: ClaimHistoryOrderByWithRelationInput | ClaimHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimHistories.
     */
    cursor?: ClaimHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimHistories.
     */
    distinct?: ClaimHistoryScalarFieldEnum | ClaimHistoryScalarFieldEnum[]
  }

  /**
   * ClaimHistory findFirstOrThrow
   */
  export type ClaimHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ClaimHistory to fetch.
     */
    where?: ClaimHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimHistories to fetch.
     */
    orderBy?: ClaimHistoryOrderByWithRelationInput | ClaimHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClaimHistories.
     */
    cursor?: ClaimHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClaimHistories.
     */
    distinct?: ClaimHistoryScalarFieldEnum | ClaimHistoryScalarFieldEnum[]
  }

  /**
   * ClaimHistory findMany
   */
  export type ClaimHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ClaimHistories to fetch.
     */
    where?: ClaimHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClaimHistories to fetch.
     */
    orderBy?: ClaimHistoryOrderByWithRelationInput | ClaimHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClaimHistories.
     */
    cursor?: ClaimHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClaimHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClaimHistories.
     */
    skip?: number
    distinct?: ClaimHistoryScalarFieldEnum | ClaimHistoryScalarFieldEnum[]
  }

  /**
   * ClaimHistory create
   */
  export type ClaimHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ClaimHistory.
     */
    data: XOR<ClaimHistoryCreateInput, ClaimHistoryUncheckedCreateInput>
  }

  /**
   * ClaimHistory createMany
   */
  export type ClaimHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClaimHistories.
     */
    data: ClaimHistoryCreateManyInput | ClaimHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClaimHistory createManyAndReturn
   */
  export type ClaimHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ClaimHistories.
     */
    data: ClaimHistoryCreateManyInput | ClaimHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClaimHistory update
   */
  export type ClaimHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ClaimHistory.
     */
    data: XOR<ClaimHistoryUpdateInput, ClaimHistoryUncheckedUpdateInput>
    /**
     * Choose, which ClaimHistory to update.
     */
    where: ClaimHistoryWhereUniqueInput
  }

  /**
   * ClaimHistory updateMany
   */
  export type ClaimHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClaimHistories.
     */
    data: XOR<ClaimHistoryUpdateManyMutationInput, ClaimHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ClaimHistories to update
     */
    where?: ClaimHistoryWhereInput
    /**
     * Limit how many ClaimHistories to update.
     */
    limit?: number
  }

  /**
   * ClaimHistory updateManyAndReturn
   */
  export type ClaimHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ClaimHistories.
     */
    data: XOR<ClaimHistoryUpdateManyMutationInput, ClaimHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ClaimHistories to update
     */
    where?: ClaimHistoryWhereInput
    /**
     * Limit how many ClaimHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClaimHistory upsert
   */
  export type ClaimHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ClaimHistory to update in case it exists.
     */
    where: ClaimHistoryWhereUniqueInput
    /**
     * In case the ClaimHistory found by the `where` argument doesn't exist, create a new ClaimHistory with this data.
     */
    create: XOR<ClaimHistoryCreateInput, ClaimHistoryUncheckedCreateInput>
    /**
     * In case the ClaimHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimHistoryUpdateInput, ClaimHistoryUncheckedUpdateInput>
  }

  /**
   * ClaimHistory delete
   */
  export type ClaimHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
    /**
     * Filter which ClaimHistory to delete.
     */
    where: ClaimHistoryWhereUniqueInput
  }

  /**
   * ClaimHistory deleteMany
   */
  export type ClaimHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClaimHistories to delete
     */
    where?: ClaimHistoryWhereInput
    /**
     * Limit how many ClaimHistories to delete.
     */
    limit?: number
  }

  /**
   * ClaimHistory without action
   */
  export type ClaimHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimHistory
     */
    select?: ClaimHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClaimHistory
     */
    omit?: ClaimHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimHistoryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    employeeNumber: 'employeeNumber',
    name: 'name',
    department: 'department',
    role: 'role',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    docNum: 'docNum',
    createdByName: 'createdByName',
    approverName: 'approverName',
    approverPosition: 'approverPosition',
    approverDepartment: 'approverDepartment',
    createdById: 'createdById',
    approverEmail: 'approverEmail',
    approverId: 'approverId',
    signerId: 'signerId',
    signerEmail: 'signerEmail',
    signerName: 'signerName',
    signerPosition: 'signerPosition',
    status: 'status',
    categoryMain: 'categoryMain',
    categorySub: 'categorySub',
    submittedAt: 'submittedAt',
    insurerComment: 'insurerComment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    claimId: 'claimId',
    type: 'type',
    fileName: 'fileName',
    url: 'url',
    uploadedAt: 'uploadedAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const CPMFormScalarFieldEnum: {
    claimId: 'claimId',
    accidentDate: 'accidentDate',
    accidentTime: 'accidentTime',
    location: 'location',
    cause: 'cause',
    repairShop: 'repairShop',
    repairShopLocation: 'repairShopLocation',
    policeDate: 'policeDate',
    policeTime: 'policeTime',
    policeStation: 'policeStation',
    damageOwnType: 'damageOwnType',
    damageOtherOwn: 'damageOtherOwn',
    damageDetail: 'damageDetail',
    damageAmount: 'damageAmount',
    victimDetail: 'victimDetail',
    partnerName: 'partnerName',
    partnerPhone: 'partnerPhone',
    partnerLocation: 'partnerLocation',
    partnerDamageDetail: 'partnerDamageDetail',
    partnerDamageAmount: 'partnerDamageAmount',
    partnerVictimDetail: 'partnerVictimDetail',
    phoneNum: 'phoneNum',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CPMFormScalarFieldEnum = (typeof CPMFormScalarFieldEnum)[keyof typeof CPMFormScalarFieldEnum]


  export const Fppa04BaseScalarFieldEnum: {
    id: 'id',
    claimId: 'claimId',
    mainType: 'mainType',
    subType: 'subType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Fppa04BaseScalarFieldEnum = (typeof Fppa04BaseScalarFieldEnum)[keyof typeof Fppa04BaseScalarFieldEnum]


  export const Fppa04CPMScalarFieldEnum: {
    baseId: 'baseId',
    eventType: 'eventType',
    claimRefNumber: 'claimRefNumber',
    eventDescription: 'eventDescription',
    productionYear: 'productionYear',
    accidentDate: 'accidentDate',
    reportedDate: 'reportedDate',
    receivedDocDate: 'receivedDocDate',
    company: 'company',
    factory: 'factory',
    policyNumber: 'policyNumber',
    surveyorRefNumber: 'surveyorRefNumber',
    insurancePayout: 'insurancePayout',
    netAmount: 'netAmount',
    signatureFiles: 'signatureFiles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Fppa04CPMScalarFieldEnum = (typeof Fppa04CPMScalarFieldEnum)[keyof typeof Fppa04CPMScalarFieldEnum]


  export const Fppa04ItemCPMScalarFieldEnum: {
    id: 'id',
    baseId: 'baseId',
    category: 'category',
    description: 'description',
    total: 'total',
    exception: 'exception'
  };

  export type Fppa04ItemCPMScalarFieldEnum = (typeof Fppa04ItemCPMScalarFieldEnum)[keyof typeof Fppa04ItemCPMScalarFieldEnum]


  export const Fppa04AdjustmentCPMScalarFieldEnum: {
    id: 'id',
    baseId: 'baseId',
    type: 'type',
    description: 'description',
    amount: 'amount'
  };

  export type Fppa04AdjustmentCPMScalarFieldEnum = (typeof Fppa04AdjustmentCPMScalarFieldEnum)[keyof typeof Fppa04AdjustmentCPMScalarFieldEnum]


  export const ClaimHistoryScalarFieldEnum: {
    id: 'id',
    claimId: 'claimId',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ClaimHistoryScalarFieldEnum = (typeof ClaimHistoryScalarFieldEnum)[keyof typeof ClaimHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ClaimStatus'
   */
  export type EnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus'>
    


  /**
   * Reference to a field of type 'ClaimStatus[]'
   */
  export type ListEnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus[]'>
    


  /**
   * Reference to a field of type 'AttachmentType'
   */
  export type EnumAttachmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttachmentType'>
    


  /**
   * Reference to a field of type 'AttachmentType[]'
   */
  export type ListEnumAttachmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttachmentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    employeeNumber?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    department?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    position?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    claimsCreated?: ClaimListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    role?: SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claimsCreated?: ClaimOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    employeeNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    department?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    position?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    claimsCreated?: ClaimListRelationFilter
  }, "id" | "email" | "employeeNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    role?: SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    employeeNumber?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    department?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    position?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClaimWhereInput = {
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    id?: StringFilter<"Claim"> | string
    docNum?: StringFilter<"Claim"> | string
    createdByName?: StringFilter<"Claim"> | string
    approverName?: StringFilter<"Claim"> | string
    approverPosition?: StringFilter<"Claim"> | string
    approverDepartment?: StringFilter<"Claim"> | string
    createdById?: StringFilter<"Claim"> | string
    approverEmail?: StringFilter<"Claim"> | string
    approverId?: StringFilter<"Claim"> | string
    signerId?: StringNullableFilter<"Claim"> | string | null
    signerEmail?: StringNullableFilter<"Claim"> | string | null
    signerName?: StringNullableFilter<"Claim"> | string | null
    signerPosition?: StringNullableFilter<"Claim"> | string | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    categoryMain?: StringNullableFilter<"Claim"> | string | null
    categorySub?: StringNullableFilter<"Claim"> | string | null
    submittedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    insurerComment?: StringNullableFilter<"Claim"> | string | null
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
    cpmForm?: XOR<CPMFormNullableScalarRelationFilter, CPMFormWhereInput> | null
    fppa04Base?: XOR<Fppa04BaseNullableScalarRelationFilter, Fppa04BaseWhereInput> | null
    history?: ClaimHistoryListRelationFilter
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    docNum?: SortOrder
    createdByName?: SortOrder
    approverName?: SortOrder
    approverPosition?: SortOrder
    approverDepartment?: SortOrder
    createdById?: SortOrder
    approverEmail?: SortOrder
    approverId?: SortOrder
    signerId?: SortOrderInput | SortOrder
    signerEmail?: SortOrderInput | SortOrder
    signerName?: SortOrderInput | SortOrder
    signerPosition?: SortOrderInput | SortOrder
    status?: SortOrder
    categoryMain?: SortOrderInput | SortOrder
    categorySub?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    insurerComment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
    cpmForm?: CPMFormOrderByWithRelationInput
    fppa04Base?: Fppa04BaseOrderByWithRelationInput
    history?: ClaimHistoryOrderByRelationAggregateInput
  }

  export type ClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    docNum?: string
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    createdByName?: StringFilter<"Claim"> | string
    approverName?: StringFilter<"Claim"> | string
    approverPosition?: StringFilter<"Claim"> | string
    approverDepartment?: StringFilter<"Claim"> | string
    createdById?: StringFilter<"Claim"> | string
    approverEmail?: StringFilter<"Claim"> | string
    approverId?: StringFilter<"Claim"> | string
    signerId?: StringNullableFilter<"Claim"> | string | null
    signerEmail?: StringNullableFilter<"Claim"> | string | null
    signerName?: StringNullableFilter<"Claim"> | string | null
    signerPosition?: StringNullableFilter<"Claim"> | string | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    categoryMain?: StringNullableFilter<"Claim"> | string | null
    categorySub?: StringNullableFilter<"Claim"> | string | null
    submittedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    insurerComment?: StringNullableFilter<"Claim"> | string | null
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
    cpmForm?: XOR<CPMFormNullableScalarRelationFilter, CPMFormWhereInput> | null
    fppa04Base?: XOR<Fppa04BaseNullableScalarRelationFilter, Fppa04BaseWhereInput> | null
    history?: ClaimHistoryListRelationFilter
  }, "id" | "docNum">

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    docNum?: SortOrder
    createdByName?: SortOrder
    approverName?: SortOrder
    approverPosition?: SortOrder
    approverDepartment?: SortOrder
    createdById?: SortOrder
    approverEmail?: SortOrder
    approverId?: SortOrder
    signerId?: SortOrderInput | SortOrder
    signerEmail?: SortOrderInput | SortOrder
    signerName?: SortOrderInput | SortOrder
    signerPosition?: SortOrderInput | SortOrder
    status?: SortOrder
    categoryMain?: SortOrderInput | SortOrder
    categorySub?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    insurerComment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    OR?: ClaimScalarWhereWithAggregatesInput[]
    NOT?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Claim"> | string
    docNum?: StringWithAggregatesFilter<"Claim"> | string
    createdByName?: StringWithAggregatesFilter<"Claim"> | string
    approverName?: StringWithAggregatesFilter<"Claim"> | string
    approverPosition?: StringWithAggregatesFilter<"Claim"> | string
    approverDepartment?: StringWithAggregatesFilter<"Claim"> | string
    createdById?: StringWithAggregatesFilter<"Claim"> | string
    approverEmail?: StringWithAggregatesFilter<"Claim"> | string
    approverId?: StringWithAggregatesFilter<"Claim"> | string
    signerId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    signerEmail?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    signerName?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    signerPosition?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    status?: EnumClaimStatusWithAggregatesFilter<"Claim"> | $Enums.ClaimStatus
    categoryMain?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    categorySub?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Claim"> | Date | string | null
    insurerComment?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    claimId?: StringFilter<"Attachment"> | string
    type?: EnumAttachmentTypeFilter<"Attachment"> | $Enums.AttachmentType
    fileName?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    uploadedAt?: DateTimeFilter<"Attachment"> | Date | string
    claim?: XOR<ClaimScalarRelationFilter, ClaimWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    claimId?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
    claim?: ClaimOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    claimId?: StringFilter<"Attachment"> | string
    type?: EnumAttachmentTypeFilter<"Attachment"> | $Enums.AttachmentType
    fileName?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    uploadedAt?: DateTimeFilter<"Attachment"> | Date | string
    claim?: XOR<ClaimScalarRelationFilter, ClaimWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    claimId?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    claimId?: StringWithAggregatesFilter<"Attachment"> | string
    type?: EnumAttachmentTypeWithAggregatesFilter<"Attachment"> | $Enums.AttachmentType
    fileName?: StringWithAggregatesFilter<"Attachment"> | string
    url?: StringWithAggregatesFilter<"Attachment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type CPMFormWhereInput = {
    AND?: CPMFormWhereInput | CPMFormWhereInput[]
    OR?: CPMFormWhereInput[]
    NOT?: CPMFormWhereInput | CPMFormWhereInput[]
    claimId?: StringFilter<"CPMForm"> | string
    accidentDate?: DateTimeFilter<"CPMForm"> | Date | string
    accidentTime?: StringFilter<"CPMForm"> | string
    location?: StringFilter<"CPMForm"> | string
    cause?: StringFilter<"CPMForm"> | string
    repairShop?: StringNullableFilter<"CPMForm"> | string | null
    repairShopLocation?: StringNullableFilter<"CPMForm"> | string | null
    policeDate?: DateTimeNullableFilter<"CPMForm"> | Date | string | null
    policeTime?: StringNullableFilter<"CPMForm"> | string | null
    policeStation?: StringNullableFilter<"CPMForm"> | string | null
    damageOwnType?: StringFilter<"CPMForm"> | string
    damageOtherOwn?: StringNullableFilter<"CPMForm"> | string | null
    damageDetail?: StringNullableFilter<"CPMForm"> | string | null
    damageAmount?: FloatNullableFilter<"CPMForm"> | number | null
    victimDetail?: StringNullableFilter<"CPMForm"> | string | null
    partnerName?: StringNullableFilter<"CPMForm"> | string | null
    partnerPhone?: StringNullableFilter<"CPMForm"> | string | null
    partnerLocation?: StringNullableFilter<"CPMForm"> | string | null
    partnerDamageDetail?: StringNullableFilter<"CPMForm"> | string | null
    partnerDamageAmount?: FloatNullableFilter<"CPMForm"> | number | null
    partnerVictimDetail?: StringNullableFilter<"CPMForm"> | string | null
    phoneNum?: StringNullableFilter<"CPMForm"> | string | null
    createdAt?: DateTimeFilter<"CPMForm"> | Date | string
    updatedAt?: DateTimeFilter<"CPMForm"> | Date | string
    claim?: XOR<ClaimScalarRelationFilter, ClaimWhereInput>
  }

  export type CPMFormOrderByWithRelationInput = {
    claimId?: SortOrder
    accidentDate?: SortOrder
    accidentTime?: SortOrder
    location?: SortOrder
    cause?: SortOrder
    repairShop?: SortOrderInput | SortOrder
    repairShopLocation?: SortOrderInput | SortOrder
    policeDate?: SortOrderInput | SortOrder
    policeTime?: SortOrderInput | SortOrder
    policeStation?: SortOrderInput | SortOrder
    damageOwnType?: SortOrder
    damageOtherOwn?: SortOrderInput | SortOrder
    damageDetail?: SortOrderInput | SortOrder
    damageAmount?: SortOrderInput | SortOrder
    victimDetail?: SortOrderInput | SortOrder
    partnerName?: SortOrderInput | SortOrder
    partnerPhone?: SortOrderInput | SortOrder
    partnerLocation?: SortOrderInput | SortOrder
    partnerDamageDetail?: SortOrderInput | SortOrder
    partnerDamageAmount?: SortOrderInput | SortOrder
    partnerVictimDetail?: SortOrderInput | SortOrder
    phoneNum?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claim?: ClaimOrderByWithRelationInput
  }

  export type CPMFormWhereUniqueInput = Prisma.AtLeast<{
    claimId?: string
    AND?: CPMFormWhereInput | CPMFormWhereInput[]
    OR?: CPMFormWhereInput[]
    NOT?: CPMFormWhereInput | CPMFormWhereInput[]
    accidentDate?: DateTimeFilter<"CPMForm"> | Date | string
    accidentTime?: StringFilter<"CPMForm"> | string
    location?: StringFilter<"CPMForm"> | string
    cause?: StringFilter<"CPMForm"> | string
    repairShop?: StringNullableFilter<"CPMForm"> | string | null
    repairShopLocation?: StringNullableFilter<"CPMForm"> | string | null
    policeDate?: DateTimeNullableFilter<"CPMForm"> | Date | string | null
    policeTime?: StringNullableFilter<"CPMForm"> | string | null
    policeStation?: StringNullableFilter<"CPMForm"> | string | null
    damageOwnType?: StringFilter<"CPMForm"> | string
    damageOtherOwn?: StringNullableFilter<"CPMForm"> | string | null
    damageDetail?: StringNullableFilter<"CPMForm"> | string | null
    damageAmount?: FloatNullableFilter<"CPMForm"> | number | null
    victimDetail?: StringNullableFilter<"CPMForm"> | string | null
    partnerName?: StringNullableFilter<"CPMForm"> | string | null
    partnerPhone?: StringNullableFilter<"CPMForm"> | string | null
    partnerLocation?: StringNullableFilter<"CPMForm"> | string | null
    partnerDamageDetail?: StringNullableFilter<"CPMForm"> | string | null
    partnerDamageAmount?: FloatNullableFilter<"CPMForm"> | number | null
    partnerVictimDetail?: StringNullableFilter<"CPMForm"> | string | null
    phoneNum?: StringNullableFilter<"CPMForm"> | string | null
    createdAt?: DateTimeFilter<"CPMForm"> | Date | string
    updatedAt?: DateTimeFilter<"CPMForm"> | Date | string
    claim?: XOR<ClaimScalarRelationFilter, ClaimWhereInput>
  }, "claimId">

  export type CPMFormOrderByWithAggregationInput = {
    claimId?: SortOrder
    accidentDate?: SortOrder
    accidentTime?: SortOrder
    location?: SortOrder
    cause?: SortOrder
    repairShop?: SortOrderInput | SortOrder
    repairShopLocation?: SortOrderInput | SortOrder
    policeDate?: SortOrderInput | SortOrder
    policeTime?: SortOrderInput | SortOrder
    policeStation?: SortOrderInput | SortOrder
    damageOwnType?: SortOrder
    damageOtherOwn?: SortOrderInput | SortOrder
    damageDetail?: SortOrderInput | SortOrder
    damageAmount?: SortOrderInput | SortOrder
    victimDetail?: SortOrderInput | SortOrder
    partnerName?: SortOrderInput | SortOrder
    partnerPhone?: SortOrderInput | SortOrder
    partnerLocation?: SortOrderInput | SortOrder
    partnerDamageDetail?: SortOrderInput | SortOrder
    partnerDamageAmount?: SortOrderInput | SortOrder
    partnerVictimDetail?: SortOrderInput | SortOrder
    phoneNum?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CPMFormCountOrderByAggregateInput
    _avg?: CPMFormAvgOrderByAggregateInput
    _max?: CPMFormMaxOrderByAggregateInput
    _min?: CPMFormMinOrderByAggregateInput
    _sum?: CPMFormSumOrderByAggregateInput
  }

  export type CPMFormScalarWhereWithAggregatesInput = {
    AND?: CPMFormScalarWhereWithAggregatesInput | CPMFormScalarWhereWithAggregatesInput[]
    OR?: CPMFormScalarWhereWithAggregatesInput[]
    NOT?: CPMFormScalarWhereWithAggregatesInput | CPMFormScalarWhereWithAggregatesInput[]
    claimId?: StringWithAggregatesFilter<"CPMForm"> | string
    accidentDate?: DateTimeWithAggregatesFilter<"CPMForm"> | Date | string
    accidentTime?: StringWithAggregatesFilter<"CPMForm"> | string
    location?: StringWithAggregatesFilter<"CPMForm"> | string
    cause?: StringWithAggregatesFilter<"CPMForm"> | string
    repairShop?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    repairShopLocation?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    policeDate?: DateTimeNullableWithAggregatesFilter<"CPMForm"> | Date | string | null
    policeTime?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    policeStation?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    damageOwnType?: StringWithAggregatesFilter<"CPMForm"> | string
    damageOtherOwn?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    damageDetail?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    damageAmount?: FloatNullableWithAggregatesFilter<"CPMForm"> | number | null
    victimDetail?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    partnerName?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    partnerPhone?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    partnerLocation?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    partnerDamageDetail?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    partnerDamageAmount?: FloatNullableWithAggregatesFilter<"CPMForm"> | number | null
    partnerVictimDetail?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    phoneNum?: StringNullableWithAggregatesFilter<"CPMForm"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CPMForm"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CPMForm"> | Date | string
  }

  export type Fppa04BaseWhereInput = {
    AND?: Fppa04BaseWhereInput | Fppa04BaseWhereInput[]
    OR?: Fppa04BaseWhereInput[]
    NOT?: Fppa04BaseWhereInput | Fppa04BaseWhereInput[]
    id?: StringFilter<"Fppa04Base"> | string
    claimId?: StringFilter<"Fppa04Base"> | string
    mainType?: StringFilter<"Fppa04Base"> | string
    subType?: StringFilter<"Fppa04Base"> | string
    createdAt?: DateTimeFilter<"Fppa04Base"> | Date | string
    updatedAt?: DateTimeFilter<"Fppa04Base"> | Date | string
    claim?: XOR<ClaimScalarRelationFilter, ClaimWhereInput>
    cpmVariant?: XOR<Fppa04CPMNullableScalarRelationFilter, Fppa04CPMWhereInput> | null
  }

  export type Fppa04BaseOrderByWithRelationInput = {
    id?: SortOrder
    claimId?: SortOrder
    mainType?: SortOrder
    subType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    claim?: ClaimOrderByWithRelationInput
    cpmVariant?: Fppa04CPMOrderByWithRelationInput
  }

  export type Fppa04BaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    claimId?: string
    AND?: Fppa04BaseWhereInput | Fppa04BaseWhereInput[]
    OR?: Fppa04BaseWhereInput[]
    NOT?: Fppa04BaseWhereInput | Fppa04BaseWhereInput[]
    mainType?: StringFilter<"Fppa04Base"> | string
    subType?: StringFilter<"Fppa04Base"> | string
    createdAt?: DateTimeFilter<"Fppa04Base"> | Date | string
    updatedAt?: DateTimeFilter<"Fppa04Base"> | Date | string
    claim?: XOR<ClaimScalarRelationFilter, ClaimWhereInput>
    cpmVariant?: XOR<Fppa04CPMNullableScalarRelationFilter, Fppa04CPMWhereInput> | null
  }, "id" | "claimId">

  export type Fppa04BaseOrderByWithAggregationInput = {
    id?: SortOrder
    claimId?: SortOrder
    mainType?: SortOrder
    subType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Fppa04BaseCountOrderByAggregateInput
    _max?: Fppa04BaseMaxOrderByAggregateInput
    _min?: Fppa04BaseMinOrderByAggregateInput
  }

  export type Fppa04BaseScalarWhereWithAggregatesInput = {
    AND?: Fppa04BaseScalarWhereWithAggregatesInput | Fppa04BaseScalarWhereWithAggregatesInput[]
    OR?: Fppa04BaseScalarWhereWithAggregatesInput[]
    NOT?: Fppa04BaseScalarWhereWithAggregatesInput | Fppa04BaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fppa04Base"> | string
    claimId?: StringWithAggregatesFilter<"Fppa04Base"> | string
    mainType?: StringWithAggregatesFilter<"Fppa04Base"> | string
    subType?: StringWithAggregatesFilter<"Fppa04Base"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Fppa04Base"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fppa04Base"> | Date | string
  }

  export type Fppa04CPMWhereInput = {
    AND?: Fppa04CPMWhereInput | Fppa04CPMWhereInput[]
    OR?: Fppa04CPMWhereInput[]
    NOT?: Fppa04CPMWhereInput | Fppa04CPMWhereInput[]
    baseId?: StringFilter<"Fppa04CPM"> | string
    eventType?: StringFilter<"Fppa04CPM"> | string
    claimRefNumber?: StringFilter<"Fppa04CPM"> | string
    eventDescription?: StringFilter<"Fppa04CPM"> | string
    productionYear?: IntFilter<"Fppa04CPM"> | number
    accidentDate?: DateTimeFilter<"Fppa04CPM"> | Date | string
    reportedDate?: DateTimeFilter<"Fppa04CPM"> | Date | string
    receivedDocDate?: DateTimeFilter<"Fppa04CPM"> | Date | string
    company?: StringFilter<"Fppa04CPM"> | string
    factory?: StringFilter<"Fppa04CPM"> | string
    policyNumber?: StringFilter<"Fppa04CPM"> | string
    surveyorRefNumber?: StringFilter<"Fppa04CPM"> | string
    insurancePayout?: FloatFilter<"Fppa04CPM"> | number
    netAmount?: FloatFilter<"Fppa04CPM"> | number
    signatureFiles?: StringNullableListFilter<"Fppa04CPM">
    createdAt?: DateTimeFilter<"Fppa04CPM"> | Date | string
    updatedAt?: DateTimeFilter<"Fppa04CPM"> | Date | string
    base?: XOR<Fppa04BaseScalarRelationFilter, Fppa04BaseWhereInput>
    items?: Fppa04ItemCPMListRelationFilter
    adjustments?: Fppa04AdjustmentCPMListRelationFilter
  }

  export type Fppa04CPMOrderByWithRelationInput = {
    baseId?: SortOrder
    eventType?: SortOrder
    claimRefNumber?: SortOrder
    eventDescription?: SortOrder
    productionYear?: SortOrder
    accidentDate?: SortOrder
    reportedDate?: SortOrder
    receivedDocDate?: SortOrder
    company?: SortOrder
    factory?: SortOrder
    policyNumber?: SortOrder
    surveyorRefNumber?: SortOrder
    insurancePayout?: SortOrder
    netAmount?: SortOrder
    signatureFiles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    base?: Fppa04BaseOrderByWithRelationInput
    items?: Fppa04ItemCPMOrderByRelationAggregateInput
    adjustments?: Fppa04AdjustmentCPMOrderByRelationAggregateInput
  }

  export type Fppa04CPMWhereUniqueInput = Prisma.AtLeast<{
    baseId?: string
    AND?: Fppa04CPMWhereInput | Fppa04CPMWhereInput[]
    OR?: Fppa04CPMWhereInput[]
    NOT?: Fppa04CPMWhereInput | Fppa04CPMWhereInput[]
    eventType?: StringFilter<"Fppa04CPM"> | string
    claimRefNumber?: StringFilter<"Fppa04CPM"> | string
    eventDescription?: StringFilter<"Fppa04CPM"> | string
    productionYear?: IntFilter<"Fppa04CPM"> | number
    accidentDate?: DateTimeFilter<"Fppa04CPM"> | Date | string
    reportedDate?: DateTimeFilter<"Fppa04CPM"> | Date | string
    receivedDocDate?: DateTimeFilter<"Fppa04CPM"> | Date | string
    company?: StringFilter<"Fppa04CPM"> | string
    factory?: StringFilter<"Fppa04CPM"> | string
    policyNumber?: StringFilter<"Fppa04CPM"> | string
    surveyorRefNumber?: StringFilter<"Fppa04CPM"> | string
    insurancePayout?: FloatFilter<"Fppa04CPM"> | number
    netAmount?: FloatFilter<"Fppa04CPM"> | number
    signatureFiles?: StringNullableListFilter<"Fppa04CPM">
    createdAt?: DateTimeFilter<"Fppa04CPM"> | Date | string
    updatedAt?: DateTimeFilter<"Fppa04CPM"> | Date | string
    base?: XOR<Fppa04BaseScalarRelationFilter, Fppa04BaseWhereInput>
    items?: Fppa04ItemCPMListRelationFilter
    adjustments?: Fppa04AdjustmentCPMListRelationFilter
  }, "baseId">

  export type Fppa04CPMOrderByWithAggregationInput = {
    baseId?: SortOrder
    eventType?: SortOrder
    claimRefNumber?: SortOrder
    eventDescription?: SortOrder
    productionYear?: SortOrder
    accidentDate?: SortOrder
    reportedDate?: SortOrder
    receivedDocDate?: SortOrder
    company?: SortOrder
    factory?: SortOrder
    policyNumber?: SortOrder
    surveyorRefNumber?: SortOrder
    insurancePayout?: SortOrder
    netAmount?: SortOrder
    signatureFiles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Fppa04CPMCountOrderByAggregateInput
    _avg?: Fppa04CPMAvgOrderByAggregateInput
    _max?: Fppa04CPMMaxOrderByAggregateInput
    _min?: Fppa04CPMMinOrderByAggregateInput
    _sum?: Fppa04CPMSumOrderByAggregateInput
  }

  export type Fppa04CPMScalarWhereWithAggregatesInput = {
    AND?: Fppa04CPMScalarWhereWithAggregatesInput | Fppa04CPMScalarWhereWithAggregatesInput[]
    OR?: Fppa04CPMScalarWhereWithAggregatesInput[]
    NOT?: Fppa04CPMScalarWhereWithAggregatesInput | Fppa04CPMScalarWhereWithAggregatesInput[]
    baseId?: StringWithAggregatesFilter<"Fppa04CPM"> | string
    eventType?: StringWithAggregatesFilter<"Fppa04CPM"> | string
    claimRefNumber?: StringWithAggregatesFilter<"Fppa04CPM"> | string
    eventDescription?: StringWithAggregatesFilter<"Fppa04CPM"> | string
    productionYear?: IntWithAggregatesFilter<"Fppa04CPM"> | number
    accidentDate?: DateTimeWithAggregatesFilter<"Fppa04CPM"> | Date | string
    reportedDate?: DateTimeWithAggregatesFilter<"Fppa04CPM"> | Date | string
    receivedDocDate?: DateTimeWithAggregatesFilter<"Fppa04CPM"> | Date | string
    company?: StringWithAggregatesFilter<"Fppa04CPM"> | string
    factory?: StringWithAggregatesFilter<"Fppa04CPM"> | string
    policyNumber?: StringWithAggregatesFilter<"Fppa04CPM"> | string
    surveyorRefNumber?: StringWithAggregatesFilter<"Fppa04CPM"> | string
    insurancePayout?: FloatWithAggregatesFilter<"Fppa04CPM"> | number
    netAmount?: FloatWithAggregatesFilter<"Fppa04CPM"> | number
    signatureFiles?: StringNullableListFilter<"Fppa04CPM">
    createdAt?: DateTimeWithAggregatesFilter<"Fppa04CPM"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fppa04CPM"> | Date | string
  }

  export type Fppa04ItemCPMWhereInput = {
    AND?: Fppa04ItemCPMWhereInput | Fppa04ItemCPMWhereInput[]
    OR?: Fppa04ItemCPMWhereInput[]
    NOT?: Fppa04ItemCPMWhereInput | Fppa04ItemCPMWhereInput[]
    id?: StringFilter<"Fppa04ItemCPM"> | string
    baseId?: StringFilter<"Fppa04ItemCPM"> | string
    category?: StringFilter<"Fppa04ItemCPM"> | string
    description?: StringFilter<"Fppa04ItemCPM"> | string
    total?: FloatFilter<"Fppa04ItemCPM"> | number
    exception?: FloatFilter<"Fppa04ItemCPM"> | number
    variant?: XOR<Fppa04CPMScalarRelationFilter, Fppa04CPMWhereInput>
  }

  export type Fppa04ItemCPMOrderByWithRelationInput = {
    id?: SortOrder
    baseId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    total?: SortOrder
    exception?: SortOrder
    variant?: Fppa04CPMOrderByWithRelationInput
  }

  export type Fppa04ItemCPMWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Fppa04ItemCPMWhereInput | Fppa04ItemCPMWhereInput[]
    OR?: Fppa04ItemCPMWhereInput[]
    NOT?: Fppa04ItemCPMWhereInput | Fppa04ItemCPMWhereInput[]
    baseId?: StringFilter<"Fppa04ItemCPM"> | string
    category?: StringFilter<"Fppa04ItemCPM"> | string
    description?: StringFilter<"Fppa04ItemCPM"> | string
    total?: FloatFilter<"Fppa04ItemCPM"> | number
    exception?: FloatFilter<"Fppa04ItemCPM"> | number
    variant?: XOR<Fppa04CPMScalarRelationFilter, Fppa04CPMWhereInput>
  }, "id">

  export type Fppa04ItemCPMOrderByWithAggregationInput = {
    id?: SortOrder
    baseId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    total?: SortOrder
    exception?: SortOrder
    _count?: Fppa04ItemCPMCountOrderByAggregateInput
    _avg?: Fppa04ItemCPMAvgOrderByAggregateInput
    _max?: Fppa04ItemCPMMaxOrderByAggregateInput
    _min?: Fppa04ItemCPMMinOrderByAggregateInput
    _sum?: Fppa04ItemCPMSumOrderByAggregateInput
  }

  export type Fppa04ItemCPMScalarWhereWithAggregatesInput = {
    AND?: Fppa04ItemCPMScalarWhereWithAggregatesInput | Fppa04ItemCPMScalarWhereWithAggregatesInput[]
    OR?: Fppa04ItemCPMScalarWhereWithAggregatesInput[]
    NOT?: Fppa04ItemCPMScalarWhereWithAggregatesInput | Fppa04ItemCPMScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fppa04ItemCPM"> | string
    baseId?: StringWithAggregatesFilter<"Fppa04ItemCPM"> | string
    category?: StringWithAggregatesFilter<"Fppa04ItemCPM"> | string
    description?: StringWithAggregatesFilter<"Fppa04ItemCPM"> | string
    total?: FloatWithAggregatesFilter<"Fppa04ItemCPM"> | number
    exception?: FloatWithAggregatesFilter<"Fppa04ItemCPM"> | number
  }

  export type Fppa04AdjustmentCPMWhereInput = {
    AND?: Fppa04AdjustmentCPMWhereInput | Fppa04AdjustmentCPMWhereInput[]
    OR?: Fppa04AdjustmentCPMWhereInput[]
    NOT?: Fppa04AdjustmentCPMWhereInput | Fppa04AdjustmentCPMWhereInput[]
    id?: StringFilter<"Fppa04AdjustmentCPM"> | string
    baseId?: StringFilter<"Fppa04AdjustmentCPM"> | string
    type?: StringFilter<"Fppa04AdjustmentCPM"> | string
    description?: StringFilter<"Fppa04AdjustmentCPM"> | string
    amount?: FloatFilter<"Fppa04AdjustmentCPM"> | number
    variant?: XOR<Fppa04CPMScalarRelationFilter, Fppa04CPMWhereInput>
  }

  export type Fppa04AdjustmentCPMOrderByWithRelationInput = {
    id?: SortOrder
    baseId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    variant?: Fppa04CPMOrderByWithRelationInput
  }

  export type Fppa04AdjustmentCPMWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Fppa04AdjustmentCPMWhereInput | Fppa04AdjustmentCPMWhereInput[]
    OR?: Fppa04AdjustmentCPMWhereInput[]
    NOT?: Fppa04AdjustmentCPMWhereInput | Fppa04AdjustmentCPMWhereInput[]
    baseId?: StringFilter<"Fppa04AdjustmentCPM"> | string
    type?: StringFilter<"Fppa04AdjustmentCPM"> | string
    description?: StringFilter<"Fppa04AdjustmentCPM"> | string
    amount?: FloatFilter<"Fppa04AdjustmentCPM"> | number
    variant?: XOR<Fppa04CPMScalarRelationFilter, Fppa04CPMWhereInput>
  }, "id">

  export type Fppa04AdjustmentCPMOrderByWithAggregationInput = {
    id?: SortOrder
    baseId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    _count?: Fppa04AdjustmentCPMCountOrderByAggregateInput
    _avg?: Fppa04AdjustmentCPMAvgOrderByAggregateInput
    _max?: Fppa04AdjustmentCPMMaxOrderByAggregateInput
    _min?: Fppa04AdjustmentCPMMinOrderByAggregateInput
    _sum?: Fppa04AdjustmentCPMSumOrderByAggregateInput
  }

  export type Fppa04AdjustmentCPMScalarWhereWithAggregatesInput = {
    AND?: Fppa04AdjustmentCPMScalarWhereWithAggregatesInput | Fppa04AdjustmentCPMScalarWhereWithAggregatesInput[]
    OR?: Fppa04AdjustmentCPMScalarWhereWithAggregatesInput[]
    NOT?: Fppa04AdjustmentCPMScalarWhereWithAggregatesInput | Fppa04AdjustmentCPMScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fppa04AdjustmentCPM"> | string
    baseId?: StringWithAggregatesFilter<"Fppa04AdjustmentCPM"> | string
    type?: StringWithAggregatesFilter<"Fppa04AdjustmentCPM"> | string
    description?: StringWithAggregatesFilter<"Fppa04AdjustmentCPM"> | string
    amount?: FloatWithAggregatesFilter<"Fppa04AdjustmentCPM"> | number
  }

  export type ClaimHistoryWhereInput = {
    AND?: ClaimHistoryWhereInput | ClaimHistoryWhereInput[]
    OR?: ClaimHistoryWhereInput[]
    NOT?: ClaimHistoryWhereInput | ClaimHistoryWhereInput[]
    id?: StringFilter<"ClaimHistory"> | string
    claimId?: StringFilter<"ClaimHistory"> | string
    status?: EnumClaimStatusFilter<"ClaimHistory"> | $Enums.ClaimStatus
    createdAt?: DateTimeFilter<"ClaimHistory"> | Date | string
    claim?: XOR<ClaimScalarRelationFilter, ClaimWhereInput>
  }

  export type ClaimHistoryOrderByWithRelationInput = {
    id?: SortOrder
    claimId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    claim?: ClaimOrderByWithRelationInput
  }

  export type ClaimHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    claimId_status?: ClaimHistoryClaimIdStatusCompoundUniqueInput
    AND?: ClaimHistoryWhereInput | ClaimHistoryWhereInput[]
    OR?: ClaimHistoryWhereInput[]
    NOT?: ClaimHistoryWhereInput | ClaimHistoryWhereInput[]
    claimId?: StringFilter<"ClaimHistory"> | string
    status?: EnumClaimStatusFilter<"ClaimHistory"> | $Enums.ClaimStatus
    createdAt?: DateTimeFilter<"ClaimHistory"> | Date | string
    claim?: XOR<ClaimScalarRelationFilter, ClaimWhereInput>
  }, "id" | "claimId_status">

  export type ClaimHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    claimId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ClaimHistoryCountOrderByAggregateInput
    _max?: ClaimHistoryMaxOrderByAggregateInput
    _min?: ClaimHistoryMinOrderByAggregateInput
  }

  export type ClaimHistoryScalarWhereWithAggregatesInput = {
    AND?: ClaimHistoryScalarWhereWithAggregatesInput | ClaimHistoryScalarWhereWithAggregatesInput[]
    OR?: ClaimHistoryScalarWhereWithAggregatesInput[]
    NOT?: ClaimHistoryScalarWhereWithAggregatesInput | ClaimHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClaimHistory"> | string
    claimId?: StringWithAggregatesFilter<"ClaimHistory"> | string
    status?: EnumClaimStatusWithAggregatesFilter<"ClaimHistory"> | $Enums.ClaimStatus
    createdAt?: DateTimeWithAggregatesFilter<"ClaimHistory"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    employeeNumber: string
    name: string
    department?: string | null
    role?: $Enums.Role
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimsCreated?: ClaimCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    employeeNumber: string
    name: string
    department?: string | null
    role?: $Enums.Role
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claimsCreated?: ClaimUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimsCreated?: ClaimUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claimsCreated?: ClaimUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    employeeNumber: string
    name: string
    department?: string | null
    role?: $Enums.Role
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimCreateInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutClaimsCreatedInput
    attachments?: AttachmentCreateNestedManyWithoutClaimInput
    cpmForm?: CPMFormCreateNestedOneWithoutClaimInput
    fppa04Base?: Fppa04BaseCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    createdById: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutClaimInput
    cpmForm?: CPMFormUncheckedCreateNestedOneWithoutClaimInput
    fppa04Base?: Fppa04BaseUncheckedCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutClaimsCreatedNestedInput
    attachments?: AttachmentUpdateManyWithoutClaimNestedInput
    cpmForm?: CPMFormUpdateOneWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutClaimNestedInput
    cpmForm?: CPMFormUncheckedUpdateOneWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUncheckedUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateManyInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    createdById: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateInput = {
    id?: string
    type: $Enums.AttachmentType
    fileName: string
    url: string
    uploadedAt?: Date | string
    claim: ClaimCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    claimId: string
    type: $Enums.AttachmentType
    fileName: string
    url: string
    uploadedAt?: Date | string
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyInput = {
    id?: string
    claimId: string
    type: $Enums.AttachmentType
    fileName: string
    url: string
    uploadedAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPMFormCreateInput = {
    accidentDate: Date | string
    accidentTime: string
    location: string
    cause: string
    repairShop?: string | null
    repairShopLocation?: string | null
    policeDate?: Date | string | null
    policeTime?: string | null
    policeStation?: string | null
    damageOwnType: string
    damageOtherOwn?: string | null
    damageDetail?: string | null
    damageAmount?: number | null
    victimDetail?: string | null
    partnerName?: string | null
    partnerPhone?: string | null
    partnerLocation?: string | null
    partnerDamageDetail?: string | null
    partnerDamageAmount?: number | null
    partnerVictimDetail?: string | null
    phoneNum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    claim: ClaimCreateNestedOneWithoutCpmFormInput
  }

  export type CPMFormUncheckedCreateInput = {
    claimId: string
    accidentDate: Date | string
    accidentTime: string
    location: string
    cause: string
    repairShop?: string | null
    repairShopLocation?: string | null
    policeDate?: Date | string | null
    policeTime?: string | null
    policeStation?: string | null
    damageOwnType: string
    damageOtherOwn?: string | null
    damageDetail?: string | null
    damageAmount?: number | null
    victimDetail?: string | null
    partnerName?: string | null
    partnerPhone?: string | null
    partnerLocation?: string | null
    partnerDamageDetail?: string | null
    partnerDamageAmount?: number | null
    partnerVictimDetail?: string | null
    phoneNum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CPMFormUpdateInput = {
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accidentTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    repairShop?: NullableStringFieldUpdateOperationsInput | string | null
    repairShopLocation?: NullableStringFieldUpdateOperationsInput | string | null
    policeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policeTime?: NullableStringFieldUpdateOperationsInput | string | null
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null
    damageOwnType?: StringFieldUpdateOperationsInput | string
    damageOtherOwn?: NullableStringFieldUpdateOperationsInput | string | null
    damageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    victimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerName?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    partnerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    partnerVictimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUpdateOneRequiredWithoutCpmFormNestedInput
  }

  export type CPMFormUncheckedUpdateInput = {
    claimId?: StringFieldUpdateOperationsInput | string
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accidentTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    repairShop?: NullableStringFieldUpdateOperationsInput | string | null
    repairShopLocation?: NullableStringFieldUpdateOperationsInput | string | null
    policeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policeTime?: NullableStringFieldUpdateOperationsInput | string | null
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null
    damageOwnType?: StringFieldUpdateOperationsInput | string
    damageOtherOwn?: NullableStringFieldUpdateOperationsInput | string | null
    damageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    victimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerName?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    partnerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    partnerVictimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPMFormCreateManyInput = {
    claimId: string
    accidentDate: Date | string
    accidentTime: string
    location: string
    cause: string
    repairShop?: string | null
    repairShopLocation?: string | null
    policeDate?: Date | string | null
    policeTime?: string | null
    policeStation?: string | null
    damageOwnType: string
    damageOtherOwn?: string | null
    damageDetail?: string | null
    damageAmount?: number | null
    victimDetail?: string | null
    partnerName?: string | null
    partnerPhone?: string | null
    partnerLocation?: string | null
    partnerDamageDetail?: string | null
    partnerDamageAmount?: number | null
    partnerVictimDetail?: string | null
    phoneNum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CPMFormUpdateManyMutationInput = {
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accidentTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    repairShop?: NullableStringFieldUpdateOperationsInput | string | null
    repairShopLocation?: NullableStringFieldUpdateOperationsInput | string | null
    policeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policeTime?: NullableStringFieldUpdateOperationsInput | string | null
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null
    damageOwnType?: StringFieldUpdateOperationsInput | string
    damageOtherOwn?: NullableStringFieldUpdateOperationsInput | string | null
    damageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    victimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerName?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    partnerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    partnerVictimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPMFormUncheckedUpdateManyInput = {
    claimId?: StringFieldUpdateOperationsInput | string
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accidentTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    repairShop?: NullableStringFieldUpdateOperationsInput | string | null
    repairShopLocation?: NullableStringFieldUpdateOperationsInput | string | null
    policeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policeTime?: NullableStringFieldUpdateOperationsInput | string | null
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null
    damageOwnType?: StringFieldUpdateOperationsInput | string
    damageOtherOwn?: NullableStringFieldUpdateOperationsInput | string | null
    damageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    victimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerName?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    partnerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    partnerVictimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Fppa04BaseCreateInput = {
    id?: string
    mainType: string
    subType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    claim: ClaimCreateNestedOneWithoutFppa04BaseInput
    cpmVariant?: Fppa04CPMCreateNestedOneWithoutBaseInput
  }

  export type Fppa04BaseUncheckedCreateInput = {
    id?: string
    claimId: string
    mainType: string
    subType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmVariant?: Fppa04CPMUncheckedCreateNestedOneWithoutBaseInput
  }

  export type Fppa04BaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mainType?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUpdateOneRequiredWithoutFppa04BaseNestedInput
    cpmVariant?: Fppa04CPMUpdateOneWithoutBaseNestedInput
  }

  export type Fppa04BaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    mainType?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmVariant?: Fppa04CPMUncheckedUpdateOneWithoutBaseNestedInput
  }

  export type Fppa04BaseCreateManyInput = {
    id?: string
    claimId: string
    mainType: string
    subType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Fppa04BaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mainType?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Fppa04BaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    mainType?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Fppa04CPMCreateInput = {
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    base: Fppa04BaseCreateNestedOneWithoutCpmVariantInput
    items?: Fppa04ItemCPMCreateNestedManyWithoutVariantInput
    adjustments?: Fppa04AdjustmentCPMCreateNestedManyWithoutVariantInput
  }

  export type Fppa04CPMUncheckedCreateInput = {
    baseId: string
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: Fppa04ItemCPMUncheckedCreateNestedManyWithoutVariantInput
    adjustments?: Fppa04AdjustmentCPMUncheckedCreateNestedManyWithoutVariantInput
  }

  export type Fppa04CPMUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    base?: Fppa04BaseUpdateOneRequiredWithoutCpmVariantNestedInput
    items?: Fppa04ItemCPMUpdateManyWithoutVariantNestedInput
    adjustments?: Fppa04AdjustmentCPMUpdateManyWithoutVariantNestedInput
  }

  export type Fppa04CPMUncheckedUpdateInput = {
    baseId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: Fppa04ItemCPMUncheckedUpdateManyWithoutVariantNestedInput
    adjustments?: Fppa04AdjustmentCPMUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type Fppa04CPMCreateManyInput = {
    baseId: string
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Fppa04CPMUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Fppa04CPMUncheckedUpdateManyInput = {
    baseId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Fppa04ItemCPMCreateInput = {
    id?: string
    category: string
    description: string
    total: number
    exception: number
    variant: Fppa04CPMCreateNestedOneWithoutItemsInput
  }

  export type Fppa04ItemCPMUncheckedCreateInput = {
    id?: string
    baseId: string
    category: string
    description: string
    total: number
    exception: number
  }

  export type Fppa04ItemCPMUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    exception?: FloatFieldUpdateOperationsInput | number
    variant?: Fppa04CPMUpdateOneRequiredWithoutItemsNestedInput
  }

  export type Fppa04ItemCPMUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    exception?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04ItemCPMCreateManyInput = {
    id?: string
    baseId: string
    category: string
    description: string
    total: number
    exception: number
  }

  export type Fppa04ItemCPMUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    exception?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04ItemCPMUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    exception?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04AdjustmentCPMCreateInput = {
    id?: string
    type: string
    description: string
    amount: number
    variant: Fppa04CPMCreateNestedOneWithoutAdjustmentsInput
  }

  export type Fppa04AdjustmentCPMUncheckedCreateInput = {
    id?: string
    baseId: string
    type: string
    description: string
    amount: number
  }

  export type Fppa04AdjustmentCPMUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    variant?: Fppa04CPMUpdateOneRequiredWithoutAdjustmentsNestedInput
  }

  export type Fppa04AdjustmentCPMUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04AdjustmentCPMCreateManyInput = {
    id?: string
    baseId: string
    type: string
    description: string
    amount: number
  }

  export type Fppa04AdjustmentCPMUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04AdjustmentCPMUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ClaimHistoryCreateInput = {
    id?: string
    status: $Enums.ClaimStatus
    createdAt?: Date | string
    claim: ClaimCreateNestedOneWithoutHistoryInput
  }

  export type ClaimHistoryUncheckedCreateInput = {
    id?: string
    claimId: string
    status: $Enums.ClaimStatus
    createdAt?: Date | string
  }

  export type ClaimHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type ClaimHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimHistoryCreateManyInput = {
    id?: string
    claimId: string
    status: $Enums.ClaimStatus
    createdAt?: Date | string
  }

  export type ClaimHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClaimListRelationFilter = {
    every?: ClaimWhereInput
    some?: ClaimWhereInput
    none?: ClaimWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    name?: SortOrder
    department?: SortOrder
    role?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    name?: SortOrder
    department?: SortOrder
    role?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    employeeNumber?: SortOrder
    name?: SortOrder
    department?: SortOrder
    role?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type CPMFormNullableScalarRelationFilter = {
    is?: CPMFormWhereInput | null
    isNot?: CPMFormWhereInput | null
  }

  export type Fppa04BaseNullableScalarRelationFilter = {
    is?: Fppa04BaseWhereInput | null
    isNot?: Fppa04BaseWhereInput | null
  }

  export type ClaimHistoryListRelationFilter = {
    every?: ClaimHistoryWhereInput
    some?: ClaimHistoryWhereInput
    none?: ClaimHistoryWhereInput
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    docNum?: SortOrder
    createdByName?: SortOrder
    approverName?: SortOrder
    approverPosition?: SortOrder
    approverDepartment?: SortOrder
    createdById?: SortOrder
    approverEmail?: SortOrder
    approverId?: SortOrder
    signerId?: SortOrder
    signerEmail?: SortOrder
    signerName?: SortOrder
    signerPosition?: SortOrder
    status?: SortOrder
    categoryMain?: SortOrder
    categorySub?: SortOrder
    submittedAt?: SortOrder
    insurerComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    docNum?: SortOrder
    createdByName?: SortOrder
    approverName?: SortOrder
    approverPosition?: SortOrder
    approverDepartment?: SortOrder
    createdById?: SortOrder
    approverEmail?: SortOrder
    approverId?: SortOrder
    signerId?: SortOrder
    signerEmail?: SortOrder
    signerName?: SortOrder
    signerPosition?: SortOrder
    status?: SortOrder
    categoryMain?: SortOrder
    categorySub?: SortOrder
    submittedAt?: SortOrder
    insurerComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    docNum?: SortOrder
    createdByName?: SortOrder
    approverName?: SortOrder
    approverPosition?: SortOrder
    approverDepartment?: SortOrder
    createdById?: SortOrder
    approverEmail?: SortOrder
    approverId?: SortOrder
    signerId?: SortOrder
    signerEmail?: SortOrder
    signerName?: SortOrder
    signerPosition?: SortOrder
    status?: SortOrder
    categoryMain?: SortOrder
    categorySub?: SortOrder
    submittedAt?: SortOrder
    insurerComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAttachmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttachmentType | EnumAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttachmentType[] | ListEnumAttachmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttachmentType[] | ListEnumAttachmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttachmentTypeFilter<$PrismaModel> | $Enums.AttachmentType
  }

  export type ClaimScalarRelationFilter = {
    is?: ClaimWhereInput
    isNot?: ClaimWhereInput
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    type?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    uploadedAt?: SortOrder
  }

  export type EnumAttachmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttachmentType | EnumAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttachmentType[] | ListEnumAttachmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttachmentType[] | ListEnumAttachmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttachmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttachmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttachmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAttachmentTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CPMFormCountOrderByAggregateInput = {
    claimId?: SortOrder
    accidentDate?: SortOrder
    accidentTime?: SortOrder
    location?: SortOrder
    cause?: SortOrder
    repairShop?: SortOrder
    repairShopLocation?: SortOrder
    policeDate?: SortOrder
    policeTime?: SortOrder
    policeStation?: SortOrder
    damageOwnType?: SortOrder
    damageOtherOwn?: SortOrder
    damageDetail?: SortOrder
    damageAmount?: SortOrder
    victimDetail?: SortOrder
    partnerName?: SortOrder
    partnerPhone?: SortOrder
    partnerLocation?: SortOrder
    partnerDamageDetail?: SortOrder
    partnerDamageAmount?: SortOrder
    partnerVictimDetail?: SortOrder
    phoneNum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CPMFormAvgOrderByAggregateInput = {
    damageAmount?: SortOrder
    partnerDamageAmount?: SortOrder
  }

  export type CPMFormMaxOrderByAggregateInput = {
    claimId?: SortOrder
    accidentDate?: SortOrder
    accidentTime?: SortOrder
    location?: SortOrder
    cause?: SortOrder
    repairShop?: SortOrder
    repairShopLocation?: SortOrder
    policeDate?: SortOrder
    policeTime?: SortOrder
    policeStation?: SortOrder
    damageOwnType?: SortOrder
    damageOtherOwn?: SortOrder
    damageDetail?: SortOrder
    damageAmount?: SortOrder
    victimDetail?: SortOrder
    partnerName?: SortOrder
    partnerPhone?: SortOrder
    partnerLocation?: SortOrder
    partnerDamageDetail?: SortOrder
    partnerDamageAmount?: SortOrder
    partnerVictimDetail?: SortOrder
    phoneNum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CPMFormMinOrderByAggregateInput = {
    claimId?: SortOrder
    accidentDate?: SortOrder
    accidentTime?: SortOrder
    location?: SortOrder
    cause?: SortOrder
    repairShop?: SortOrder
    repairShopLocation?: SortOrder
    policeDate?: SortOrder
    policeTime?: SortOrder
    policeStation?: SortOrder
    damageOwnType?: SortOrder
    damageOtherOwn?: SortOrder
    damageDetail?: SortOrder
    damageAmount?: SortOrder
    victimDetail?: SortOrder
    partnerName?: SortOrder
    partnerPhone?: SortOrder
    partnerLocation?: SortOrder
    partnerDamageDetail?: SortOrder
    partnerDamageAmount?: SortOrder
    partnerVictimDetail?: SortOrder
    phoneNum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CPMFormSumOrderByAggregateInput = {
    damageAmount?: SortOrder
    partnerDamageAmount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Fppa04CPMNullableScalarRelationFilter = {
    is?: Fppa04CPMWhereInput | null
    isNot?: Fppa04CPMWhereInput | null
  }

  export type Fppa04BaseCountOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    mainType?: SortOrder
    subType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Fppa04BaseMaxOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    mainType?: SortOrder
    subType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Fppa04BaseMinOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    mainType?: SortOrder
    subType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Fppa04BaseScalarRelationFilter = {
    is?: Fppa04BaseWhereInput
    isNot?: Fppa04BaseWhereInput
  }

  export type Fppa04ItemCPMListRelationFilter = {
    every?: Fppa04ItemCPMWhereInput
    some?: Fppa04ItemCPMWhereInput
    none?: Fppa04ItemCPMWhereInput
  }

  export type Fppa04AdjustmentCPMListRelationFilter = {
    every?: Fppa04AdjustmentCPMWhereInput
    some?: Fppa04AdjustmentCPMWhereInput
    none?: Fppa04AdjustmentCPMWhereInput
  }

  export type Fppa04ItemCPMOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Fppa04AdjustmentCPMOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Fppa04CPMCountOrderByAggregateInput = {
    baseId?: SortOrder
    eventType?: SortOrder
    claimRefNumber?: SortOrder
    eventDescription?: SortOrder
    productionYear?: SortOrder
    accidentDate?: SortOrder
    reportedDate?: SortOrder
    receivedDocDate?: SortOrder
    company?: SortOrder
    factory?: SortOrder
    policyNumber?: SortOrder
    surveyorRefNumber?: SortOrder
    insurancePayout?: SortOrder
    netAmount?: SortOrder
    signatureFiles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Fppa04CPMAvgOrderByAggregateInput = {
    productionYear?: SortOrder
    insurancePayout?: SortOrder
    netAmount?: SortOrder
  }

  export type Fppa04CPMMaxOrderByAggregateInput = {
    baseId?: SortOrder
    eventType?: SortOrder
    claimRefNumber?: SortOrder
    eventDescription?: SortOrder
    productionYear?: SortOrder
    accidentDate?: SortOrder
    reportedDate?: SortOrder
    receivedDocDate?: SortOrder
    company?: SortOrder
    factory?: SortOrder
    policyNumber?: SortOrder
    surveyorRefNumber?: SortOrder
    insurancePayout?: SortOrder
    netAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Fppa04CPMMinOrderByAggregateInput = {
    baseId?: SortOrder
    eventType?: SortOrder
    claimRefNumber?: SortOrder
    eventDescription?: SortOrder
    productionYear?: SortOrder
    accidentDate?: SortOrder
    reportedDate?: SortOrder
    receivedDocDate?: SortOrder
    company?: SortOrder
    factory?: SortOrder
    policyNumber?: SortOrder
    surveyorRefNumber?: SortOrder
    insurancePayout?: SortOrder
    netAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Fppa04CPMSumOrderByAggregateInput = {
    productionYear?: SortOrder
    insurancePayout?: SortOrder
    netAmount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Fppa04CPMScalarRelationFilter = {
    is?: Fppa04CPMWhereInput
    isNot?: Fppa04CPMWhereInput
  }

  export type Fppa04ItemCPMCountOrderByAggregateInput = {
    id?: SortOrder
    baseId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    total?: SortOrder
    exception?: SortOrder
  }

  export type Fppa04ItemCPMAvgOrderByAggregateInput = {
    total?: SortOrder
    exception?: SortOrder
  }

  export type Fppa04ItemCPMMaxOrderByAggregateInput = {
    id?: SortOrder
    baseId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    total?: SortOrder
    exception?: SortOrder
  }

  export type Fppa04ItemCPMMinOrderByAggregateInput = {
    id?: SortOrder
    baseId?: SortOrder
    category?: SortOrder
    description?: SortOrder
    total?: SortOrder
    exception?: SortOrder
  }

  export type Fppa04ItemCPMSumOrderByAggregateInput = {
    total?: SortOrder
    exception?: SortOrder
  }

  export type Fppa04AdjustmentCPMCountOrderByAggregateInput = {
    id?: SortOrder
    baseId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type Fppa04AdjustmentCPMAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Fppa04AdjustmentCPMMaxOrderByAggregateInput = {
    id?: SortOrder
    baseId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type Fppa04AdjustmentCPMMinOrderByAggregateInput = {
    id?: SortOrder
    baseId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type Fppa04AdjustmentCPMSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ClaimHistoryClaimIdStatusCompoundUniqueInput = {
    claimId: string
    status: $Enums.ClaimStatus
  }

  export type ClaimHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClaimHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClaimHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    claimId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClaimCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ClaimCreateWithoutCreatedByInput, ClaimUncheckedCreateWithoutCreatedByInput> | ClaimCreateWithoutCreatedByInput[] | ClaimUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutCreatedByInput | ClaimCreateOrConnectWithoutCreatedByInput[]
    createMany?: ClaimCreateManyCreatedByInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ClaimCreateWithoutCreatedByInput, ClaimUncheckedCreateWithoutCreatedByInput> | ClaimCreateWithoutCreatedByInput[] | ClaimUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutCreatedByInput | ClaimCreateOrConnectWithoutCreatedByInput[]
    createMany?: ClaimCreateManyCreatedByInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClaimUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ClaimCreateWithoutCreatedByInput, ClaimUncheckedCreateWithoutCreatedByInput> | ClaimCreateWithoutCreatedByInput[] | ClaimUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutCreatedByInput | ClaimCreateOrConnectWithoutCreatedByInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutCreatedByInput | ClaimUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ClaimCreateManyCreatedByInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutCreatedByInput | ClaimUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutCreatedByInput | ClaimUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ClaimCreateWithoutCreatedByInput, ClaimUncheckedCreateWithoutCreatedByInput> | ClaimCreateWithoutCreatedByInput[] | ClaimUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutCreatedByInput | ClaimCreateOrConnectWithoutCreatedByInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutCreatedByInput | ClaimUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ClaimCreateManyCreatedByInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutCreatedByInput | ClaimUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutCreatedByInput | ClaimUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClaimsCreatedInput = {
    create?: XOR<UserCreateWithoutClaimsCreatedInput, UserUncheckedCreateWithoutClaimsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutClaimInput = {
    create?: XOR<AttachmentCreateWithoutClaimInput, AttachmentUncheckedCreateWithoutClaimInput> | AttachmentCreateWithoutClaimInput[] | AttachmentUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutClaimInput | AttachmentCreateOrConnectWithoutClaimInput[]
    createMany?: AttachmentCreateManyClaimInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CPMFormCreateNestedOneWithoutClaimInput = {
    create?: XOR<CPMFormCreateWithoutClaimInput, CPMFormUncheckedCreateWithoutClaimInput>
    connectOrCreate?: CPMFormCreateOrConnectWithoutClaimInput
    connect?: CPMFormWhereUniqueInput
  }

  export type Fppa04BaseCreateNestedOneWithoutClaimInput = {
    create?: XOR<Fppa04BaseCreateWithoutClaimInput, Fppa04BaseUncheckedCreateWithoutClaimInput>
    connectOrCreate?: Fppa04BaseCreateOrConnectWithoutClaimInput
    connect?: Fppa04BaseWhereUniqueInput
  }

  export type ClaimHistoryCreateNestedManyWithoutClaimInput = {
    create?: XOR<ClaimHistoryCreateWithoutClaimInput, ClaimHistoryUncheckedCreateWithoutClaimInput> | ClaimHistoryCreateWithoutClaimInput[] | ClaimHistoryUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimHistoryCreateOrConnectWithoutClaimInput | ClaimHistoryCreateOrConnectWithoutClaimInput[]
    createMany?: ClaimHistoryCreateManyClaimInputEnvelope
    connect?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<AttachmentCreateWithoutClaimInput, AttachmentUncheckedCreateWithoutClaimInput> | AttachmentCreateWithoutClaimInput[] | AttachmentUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutClaimInput | AttachmentCreateOrConnectWithoutClaimInput[]
    createMany?: AttachmentCreateManyClaimInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CPMFormUncheckedCreateNestedOneWithoutClaimInput = {
    create?: XOR<CPMFormCreateWithoutClaimInput, CPMFormUncheckedCreateWithoutClaimInput>
    connectOrCreate?: CPMFormCreateOrConnectWithoutClaimInput
    connect?: CPMFormWhereUniqueInput
  }

  export type Fppa04BaseUncheckedCreateNestedOneWithoutClaimInput = {
    create?: XOR<Fppa04BaseCreateWithoutClaimInput, Fppa04BaseUncheckedCreateWithoutClaimInput>
    connectOrCreate?: Fppa04BaseCreateOrConnectWithoutClaimInput
    connect?: Fppa04BaseWhereUniqueInput
  }

  export type ClaimHistoryUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<ClaimHistoryCreateWithoutClaimInput, ClaimHistoryUncheckedCreateWithoutClaimInput> | ClaimHistoryCreateWithoutClaimInput[] | ClaimHistoryUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimHistoryCreateOrConnectWithoutClaimInput | ClaimHistoryCreateOrConnectWithoutClaimInput[]
    createMany?: ClaimHistoryCreateManyClaimInputEnvelope
    connect?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
  }

  export type EnumClaimStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClaimStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutClaimsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutClaimsCreatedInput, UserUncheckedCreateWithoutClaimsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsCreatedInput
    upsert?: UserUpsertWithoutClaimsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaimsCreatedInput, UserUpdateWithoutClaimsCreatedInput>, UserUncheckedUpdateWithoutClaimsCreatedInput>
  }

  export type AttachmentUpdateManyWithoutClaimNestedInput = {
    create?: XOR<AttachmentCreateWithoutClaimInput, AttachmentUncheckedCreateWithoutClaimInput> | AttachmentCreateWithoutClaimInput[] | AttachmentUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutClaimInput | AttachmentCreateOrConnectWithoutClaimInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutClaimInput | AttachmentUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: AttachmentCreateManyClaimInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutClaimInput | AttachmentUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutClaimInput | AttachmentUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CPMFormUpdateOneWithoutClaimNestedInput = {
    create?: XOR<CPMFormCreateWithoutClaimInput, CPMFormUncheckedCreateWithoutClaimInput>
    connectOrCreate?: CPMFormCreateOrConnectWithoutClaimInput
    upsert?: CPMFormUpsertWithoutClaimInput
    disconnect?: CPMFormWhereInput | boolean
    delete?: CPMFormWhereInput | boolean
    connect?: CPMFormWhereUniqueInput
    update?: XOR<XOR<CPMFormUpdateToOneWithWhereWithoutClaimInput, CPMFormUpdateWithoutClaimInput>, CPMFormUncheckedUpdateWithoutClaimInput>
  }

  export type Fppa04BaseUpdateOneWithoutClaimNestedInput = {
    create?: XOR<Fppa04BaseCreateWithoutClaimInput, Fppa04BaseUncheckedCreateWithoutClaimInput>
    connectOrCreate?: Fppa04BaseCreateOrConnectWithoutClaimInput
    upsert?: Fppa04BaseUpsertWithoutClaimInput
    disconnect?: Fppa04BaseWhereInput | boolean
    delete?: Fppa04BaseWhereInput | boolean
    connect?: Fppa04BaseWhereUniqueInput
    update?: XOR<XOR<Fppa04BaseUpdateToOneWithWhereWithoutClaimInput, Fppa04BaseUpdateWithoutClaimInput>, Fppa04BaseUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimHistoryUpdateManyWithoutClaimNestedInput = {
    create?: XOR<ClaimHistoryCreateWithoutClaimInput, ClaimHistoryUncheckedCreateWithoutClaimInput> | ClaimHistoryCreateWithoutClaimInput[] | ClaimHistoryUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimHistoryCreateOrConnectWithoutClaimInput | ClaimHistoryCreateOrConnectWithoutClaimInput[]
    upsert?: ClaimHistoryUpsertWithWhereUniqueWithoutClaimInput | ClaimHistoryUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: ClaimHistoryCreateManyClaimInputEnvelope
    set?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
    disconnect?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
    delete?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
    connect?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
    update?: ClaimHistoryUpdateWithWhereUniqueWithoutClaimInput | ClaimHistoryUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: ClaimHistoryUpdateManyWithWhereWithoutClaimInput | ClaimHistoryUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: ClaimHistoryScalarWhereInput | ClaimHistoryScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<AttachmentCreateWithoutClaimInput, AttachmentUncheckedCreateWithoutClaimInput> | AttachmentCreateWithoutClaimInput[] | AttachmentUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutClaimInput | AttachmentCreateOrConnectWithoutClaimInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutClaimInput | AttachmentUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: AttachmentCreateManyClaimInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutClaimInput | AttachmentUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutClaimInput | AttachmentUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CPMFormUncheckedUpdateOneWithoutClaimNestedInput = {
    create?: XOR<CPMFormCreateWithoutClaimInput, CPMFormUncheckedCreateWithoutClaimInput>
    connectOrCreate?: CPMFormCreateOrConnectWithoutClaimInput
    upsert?: CPMFormUpsertWithoutClaimInput
    disconnect?: CPMFormWhereInput | boolean
    delete?: CPMFormWhereInput | boolean
    connect?: CPMFormWhereUniqueInput
    update?: XOR<XOR<CPMFormUpdateToOneWithWhereWithoutClaimInput, CPMFormUpdateWithoutClaimInput>, CPMFormUncheckedUpdateWithoutClaimInput>
  }

  export type Fppa04BaseUncheckedUpdateOneWithoutClaimNestedInput = {
    create?: XOR<Fppa04BaseCreateWithoutClaimInput, Fppa04BaseUncheckedCreateWithoutClaimInput>
    connectOrCreate?: Fppa04BaseCreateOrConnectWithoutClaimInput
    upsert?: Fppa04BaseUpsertWithoutClaimInput
    disconnect?: Fppa04BaseWhereInput | boolean
    delete?: Fppa04BaseWhereInput | boolean
    connect?: Fppa04BaseWhereUniqueInput
    update?: XOR<XOR<Fppa04BaseUpdateToOneWithWhereWithoutClaimInput, Fppa04BaseUpdateWithoutClaimInput>, Fppa04BaseUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimHistoryUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<ClaimHistoryCreateWithoutClaimInput, ClaimHistoryUncheckedCreateWithoutClaimInput> | ClaimHistoryCreateWithoutClaimInput[] | ClaimHistoryUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: ClaimHistoryCreateOrConnectWithoutClaimInput | ClaimHistoryCreateOrConnectWithoutClaimInput[]
    upsert?: ClaimHistoryUpsertWithWhereUniqueWithoutClaimInput | ClaimHistoryUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: ClaimHistoryCreateManyClaimInputEnvelope
    set?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
    disconnect?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
    delete?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
    connect?: ClaimHistoryWhereUniqueInput | ClaimHistoryWhereUniqueInput[]
    update?: ClaimHistoryUpdateWithWhereUniqueWithoutClaimInput | ClaimHistoryUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: ClaimHistoryUpdateManyWithWhereWithoutClaimInput | ClaimHistoryUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: ClaimHistoryScalarWhereInput | ClaimHistoryScalarWhereInput[]
  }

  export type ClaimCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<ClaimCreateWithoutAttachmentsInput, ClaimUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutAttachmentsInput
    connect?: ClaimWhereUniqueInput
  }

  export type EnumAttachmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AttachmentType
  }

  export type ClaimUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<ClaimCreateWithoutAttachmentsInput, ClaimUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutAttachmentsInput
    upsert?: ClaimUpsertWithoutAttachmentsInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutAttachmentsInput, ClaimUpdateWithoutAttachmentsInput>, ClaimUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ClaimCreateNestedOneWithoutCpmFormInput = {
    create?: XOR<ClaimCreateWithoutCpmFormInput, ClaimUncheckedCreateWithoutCpmFormInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutCpmFormInput
    connect?: ClaimWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClaimUpdateOneRequiredWithoutCpmFormNestedInput = {
    create?: XOR<ClaimCreateWithoutCpmFormInput, ClaimUncheckedCreateWithoutCpmFormInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutCpmFormInput
    upsert?: ClaimUpsertWithoutCpmFormInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutCpmFormInput, ClaimUpdateWithoutCpmFormInput>, ClaimUncheckedUpdateWithoutCpmFormInput>
  }

  export type ClaimCreateNestedOneWithoutFppa04BaseInput = {
    create?: XOR<ClaimCreateWithoutFppa04BaseInput, ClaimUncheckedCreateWithoutFppa04BaseInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutFppa04BaseInput
    connect?: ClaimWhereUniqueInput
  }

  export type Fppa04CPMCreateNestedOneWithoutBaseInput = {
    create?: XOR<Fppa04CPMCreateWithoutBaseInput, Fppa04CPMUncheckedCreateWithoutBaseInput>
    connectOrCreate?: Fppa04CPMCreateOrConnectWithoutBaseInput
    connect?: Fppa04CPMWhereUniqueInput
  }

  export type Fppa04CPMUncheckedCreateNestedOneWithoutBaseInput = {
    create?: XOR<Fppa04CPMCreateWithoutBaseInput, Fppa04CPMUncheckedCreateWithoutBaseInput>
    connectOrCreate?: Fppa04CPMCreateOrConnectWithoutBaseInput
    connect?: Fppa04CPMWhereUniqueInput
  }

  export type ClaimUpdateOneRequiredWithoutFppa04BaseNestedInput = {
    create?: XOR<ClaimCreateWithoutFppa04BaseInput, ClaimUncheckedCreateWithoutFppa04BaseInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutFppa04BaseInput
    upsert?: ClaimUpsertWithoutFppa04BaseInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutFppa04BaseInput, ClaimUpdateWithoutFppa04BaseInput>, ClaimUncheckedUpdateWithoutFppa04BaseInput>
  }

  export type Fppa04CPMUpdateOneWithoutBaseNestedInput = {
    create?: XOR<Fppa04CPMCreateWithoutBaseInput, Fppa04CPMUncheckedCreateWithoutBaseInput>
    connectOrCreate?: Fppa04CPMCreateOrConnectWithoutBaseInput
    upsert?: Fppa04CPMUpsertWithoutBaseInput
    disconnect?: Fppa04CPMWhereInput | boolean
    delete?: Fppa04CPMWhereInput | boolean
    connect?: Fppa04CPMWhereUniqueInput
    update?: XOR<XOR<Fppa04CPMUpdateToOneWithWhereWithoutBaseInput, Fppa04CPMUpdateWithoutBaseInput>, Fppa04CPMUncheckedUpdateWithoutBaseInput>
  }

  export type Fppa04CPMUncheckedUpdateOneWithoutBaseNestedInput = {
    create?: XOR<Fppa04CPMCreateWithoutBaseInput, Fppa04CPMUncheckedCreateWithoutBaseInput>
    connectOrCreate?: Fppa04CPMCreateOrConnectWithoutBaseInput
    upsert?: Fppa04CPMUpsertWithoutBaseInput
    disconnect?: Fppa04CPMWhereInput | boolean
    delete?: Fppa04CPMWhereInput | boolean
    connect?: Fppa04CPMWhereUniqueInput
    update?: XOR<XOR<Fppa04CPMUpdateToOneWithWhereWithoutBaseInput, Fppa04CPMUpdateWithoutBaseInput>, Fppa04CPMUncheckedUpdateWithoutBaseInput>
  }

  export type Fppa04CPMCreatesignatureFilesInput = {
    set: string[]
  }

  export type Fppa04BaseCreateNestedOneWithoutCpmVariantInput = {
    create?: XOR<Fppa04BaseCreateWithoutCpmVariantInput, Fppa04BaseUncheckedCreateWithoutCpmVariantInput>
    connectOrCreate?: Fppa04BaseCreateOrConnectWithoutCpmVariantInput
    connect?: Fppa04BaseWhereUniqueInput
  }

  export type Fppa04ItemCPMCreateNestedManyWithoutVariantInput = {
    create?: XOR<Fppa04ItemCPMCreateWithoutVariantInput, Fppa04ItemCPMUncheckedCreateWithoutVariantInput> | Fppa04ItemCPMCreateWithoutVariantInput[] | Fppa04ItemCPMUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: Fppa04ItemCPMCreateOrConnectWithoutVariantInput | Fppa04ItemCPMCreateOrConnectWithoutVariantInput[]
    createMany?: Fppa04ItemCPMCreateManyVariantInputEnvelope
    connect?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
  }

  export type Fppa04AdjustmentCPMCreateNestedManyWithoutVariantInput = {
    create?: XOR<Fppa04AdjustmentCPMCreateWithoutVariantInput, Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput> | Fppa04AdjustmentCPMCreateWithoutVariantInput[] | Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput | Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput[]
    createMany?: Fppa04AdjustmentCPMCreateManyVariantInputEnvelope
    connect?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
  }

  export type Fppa04ItemCPMUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<Fppa04ItemCPMCreateWithoutVariantInput, Fppa04ItemCPMUncheckedCreateWithoutVariantInput> | Fppa04ItemCPMCreateWithoutVariantInput[] | Fppa04ItemCPMUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: Fppa04ItemCPMCreateOrConnectWithoutVariantInput | Fppa04ItemCPMCreateOrConnectWithoutVariantInput[]
    createMany?: Fppa04ItemCPMCreateManyVariantInputEnvelope
    connect?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
  }

  export type Fppa04AdjustmentCPMUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<Fppa04AdjustmentCPMCreateWithoutVariantInput, Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput> | Fppa04AdjustmentCPMCreateWithoutVariantInput[] | Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput | Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput[]
    createMany?: Fppa04AdjustmentCPMCreateManyVariantInputEnvelope
    connect?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Fppa04CPMUpdatesignatureFilesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Fppa04BaseUpdateOneRequiredWithoutCpmVariantNestedInput = {
    create?: XOR<Fppa04BaseCreateWithoutCpmVariantInput, Fppa04BaseUncheckedCreateWithoutCpmVariantInput>
    connectOrCreate?: Fppa04BaseCreateOrConnectWithoutCpmVariantInput
    upsert?: Fppa04BaseUpsertWithoutCpmVariantInput
    connect?: Fppa04BaseWhereUniqueInput
    update?: XOR<XOR<Fppa04BaseUpdateToOneWithWhereWithoutCpmVariantInput, Fppa04BaseUpdateWithoutCpmVariantInput>, Fppa04BaseUncheckedUpdateWithoutCpmVariantInput>
  }

  export type Fppa04ItemCPMUpdateManyWithoutVariantNestedInput = {
    create?: XOR<Fppa04ItemCPMCreateWithoutVariantInput, Fppa04ItemCPMUncheckedCreateWithoutVariantInput> | Fppa04ItemCPMCreateWithoutVariantInput[] | Fppa04ItemCPMUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: Fppa04ItemCPMCreateOrConnectWithoutVariantInput | Fppa04ItemCPMCreateOrConnectWithoutVariantInput[]
    upsert?: Fppa04ItemCPMUpsertWithWhereUniqueWithoutVariantInput | Fppa04ItemCPMUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: Fppa04ItemCPMCreateManyVariantInputEnvelope
    set?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
    disconnect?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
    delete?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
    connect?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
    update?: Fppa04ItemCPMUpdateWithWhereUniqueWithoutVariantInput | Fppa04ItemCPMUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: Fppa04ItemCPMUpdateManyWithWhereWithoutVariantInput | Fppa04ItemCPMUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: Fppa04ItemCPMScalarWhereInput | Fppa04ItemCPMScalarWhereInput[]
  }

  export type Fppa04AdjustmentCPMUpdateManyWithoutVariantNestedInput = {
    create?: XOR<Fppa04AdjustmentCPMCreateWithoutVariantInput, Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput> | Fppa04AdjustmentCPMCreateWithoutVariantInput[] | Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput | Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput[]
    upsert?: Fppa04AdjustmentCPMUpsertWithWhereUniqueWithoutVariantInput | Fppa04AdjustmentCPMUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: Fppa04AdjustmentCPMCreateManyVariantInputEnvelope
    set?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
    disconnect?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
    delete?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
    connect?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
    update?: Fppa04AdjustmentCPMUpdateWithWhereUniqueWithoutVariantInput | Fppa04AdjustmentCPMUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: Fppa04AdjustmentCPMUpdateManyWithWhereWithoutVariantInput | Fppa04AdjustmentCPMUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: Fppa04AdjustmentCPMScalarWhereInput | Fppa04AdjustmentCPMScalarWhereInput[]
  }

  export type Fppa04ItemCPMUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<Fppa04ItemCPMCreateWithoutVariantInput, Fppa04ItemCPMUncheckedCreateWithoutVariantInput> | Fppa04ItemCPMCreateWithoutVariantInput[] | Fppa04ItemCPMUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: Fppa04ItemCPMCreateOrConnectWithoutVariantInput | Fppa04ItemCPMCreateOrConnectWithoutVariantInput[]
    upsert?: Fppa04ItemCPMUpsertWithWhereUniqueWithoutVariantInput | Fppa04ItemCPMUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: Fppa04ItemCPMCreateManyVariantInputEnvelope
    set?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
    disconnect?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
    delete?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
    connect?: Fppa04ItemCPMWhereUniqueInput | Fppa04ItemCPMWhereUniqueInput[]
    update?: Fppa04ItemCPMUpdateWithWhereUniqueWithoutVariantInput | Fppa04ItemCPMUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: Fppa04ItemCPMUpdateManyWithWhereWithoutVariantInput | Fppa04ItemCPMUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: Fppa04ItemCPMScalarWhereInput | Fppa04ItemCPMScalarWhereInput[]
  }

  export type Fppa04AdjustmentCPMUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<Fppa04AdjustmentCPMCreateWithoutVariantInput, Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput> | Fppa04AdjustmentCPMCreateWithoutVariantInput[] | Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput | Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput[]
    upsert?: Fppa04AdjustmentCPMUpsertWithWhereUniqueWithoutVariantInput | Fppa04AdjustmentCPMUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: Fppa04AdjustmentCPMCreateManyVariantInputEnvelope
    set?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
    disconnect?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
    delete?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
    connect?: Fppa04AdjustmentCPMWhereUniqueInput | Fppa04AdjustmentCPMWhereUniqueInput[]
    update?: Fppa04AdjustmentCPMUpdateWithWhereUniqueWithoutVariantInput | Fppa04AdjustmentCPMUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: Fppa04AdjustmentCPMUpdateManyWithWhereWithoutVariantInput | Fppa04AdjustmentCPMUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: Fppa04AdjustmentCPMScalarWhereInput | Fppa04AdjustmentCPMScalarWhereInput[]
  }

  export type Fppa04CPMCreateNestedOneWithoutItemsInput = {
    create?: XOR<Fppa04CPMCreateWithoutItemsInput, Fppa04CPMUncheckedCreateWithoutItemsInput>
    connectOrCreate?: Fppa04CPMCreateOrConnectWithoutItemsInput
    connect?: Fppa04CPMWhereUniqueInput
  }

  export type Fppa04CPMUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<Fppa04CPMCreateWithoutItemsInput, Fppa04CPMUncheckedCreateWithoutItemsInput>
    connectOrCreate?: Fppa04CPMCreateOrConnectWithoutItemsInput
    upsert?: Fppa04CPMUpsertWithoutItemsInput
    connect?: Fppa04CPMWhereUniqueInput
    update?: XOR<XOR<Fppa04CPMUpdateToOneWithWhereWithoutItemsInput, Fppa04CPMUpdateWithoutItemsInput>, Fppa04CPMUncheckedUpdateWithoutItemsInput>
  }

  export type Fppa04CPMCreateNestedOneWithoutAdjustmentsInput = {
    create?: XOR<Fppa04CPMCreateWithoutAdjustmentsInput, Fppa04CPMUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: Fppa04CPMCreateOrConnectWithoutAdjustmentsInput
    connect?: Fppa04CPMWhereUniqueInput
  }

  export type Fppa04CPMUpdateOneRequiredWithoutAdjustmentsNestedInput = {
    create?: XOR<Fppa04CPMCreateWithoutAdjustmentsInput, Fppa04CPMUncheckedCreateWithoutAdjustmentsInput>
    connectOrCreate?: Fppa04CPMCreateOrConnectWithoutAdjustmentsInput
    upsert?: Fppa04CPMUpsertWithoutAdjustmentsInput
    connect?: Fppa04CPMWhereUniqueInput
    update?: XOR<XOR<Fppa04CPMUpdateToOneWithWhereWithoutAdjustmentsInput, Fppa04CPMUpdateWithoutAdjustmentsInput>, Fppa04CPMUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type ClaimCreateNestedOneWithoutHistoryInput = {
    create?: XOR<ClaimCreateWithoutHistoryInput, ClaimUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutHistoryInput
    connect?: ClaimWhereUniqueInput
  }

  export type ClaimUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<ClaimCreateWithoutHistoryInput, ClaimUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutHistoryInput
    upsert?: ClaimUpsertWithoutHistoryInput
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutHistoryInput, ClaimUpdateWithoutHistoryInput>, ClaimUncheckedUpdateWithoutHistoryInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttachmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AttachmentType | EnumAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttachmentType[] | ListEnumAttachmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttachmentType[] | ListEnumAttachmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttachmentTypeFilter<$PrismaModel> | $Enums.AttachmentType
  }

  export type NestedEnumAttachmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttachmentType | EnumAttachmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AttachmentType[] | ListEnumAttachmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttachmentType[] | ListEnumAttachmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAttachmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AttachmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttachmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAttachmentTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ClaimCreateWithoutCreatedByInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutClaimInput
    cpmForm?: CPMFormCreateNestedOneWithoutClaimInput
    fppa04Base?: Fppa04BaseCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutCreatedByInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutClaimInput
    cpmForm?: CPMFormUncheckedCreateNestedOneWithoutClaimInput
    fppa04Base?: Fppa04BaseUncheckedCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutCreatedByInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutCreatedByInput, ClaimUncheckedCreateWithoutCreatedByInput>
  }

  export type ClaimCreateManyCreatedByInputEnvelope = {
    data: ClaimCreateManyCreatedByInput | ClaimCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ClaimUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutCreatedByInput, ClaimUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ClaimCreateWithoutCreatedByInput, ClaimUncheckedCreateWithoutCreatedByInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutCreatedByInput, ClaimUncheckedUpdateWithoutCreatedByInput>
  }

  export type ClaimUpdateManyWithWhereWithoutCreatedByInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ClaimScalarWhereInput = {
    AND?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    OR?: ClaimScalarWhereInput[]
    NOT?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    id?: StringFilter<"Claim"> | string
    docNum?: StringFilter<"Claim"> | string
    createdByName?: StringFilter<"Claim"> | string
    approverName?: StringFilter<"Claim"> | string
    approverPosition?: StringFilter<"Claim"> | string
    approverDepartment?: StringFilter<"Claim"> | string
    createdById?: StringFilter<"Claim"> | string
    approverEmail?: StringFilter<"Claim"> | string
    approverId?: StringFilter<"Claim"> | string
    signerId?: StringNullableFilter<"Claim"> | string | null
    signerEmail?: StringNullableFilter<"Claim"> | string | null
    signerName?: StringNullableFilter<"Claim"> | string | null
    signerPosition?: StringNullableFilter<"Claim"> | string | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    categoryMain?: StringNullableFilter<"Claim"> | string | null
    categorySub?: StringNullableFilter<"Claim"> | string | null
    submittedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    insurerComment?: StringNullableFilter<"Claim"> | string | null
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
  }

  export type UserCreateWithoutClaimsCreatedInput = {
    id?: string
    email: string
    employeeNumber: string
    name: string
    department?: string | null
    role?: $Enums.Role
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutClaimsCreatedInput = {
    id?: string
    email: string
    employeeNumber: string
    name: string
    department?: string | null
    role?: $Enums.Role
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutClaimsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimsCreatedInput, UserUncheckedCreateWithoutClaimsCreatedInput>
  }

  export type AttachmentCreateWithoutClaimInput = {
    id?: string
    type: $Enums.AttachmentType
    fileName: string
    url: string
    uploadedAt?: Date | string
  }

  export type AttachmentUncheckedCreateWithoutClaimInput = {
    id?: string
    type: $Enums.AttachmentType
    fileName: string
    url: string
    uploadedAt?: Date | string
  }

  export type AttachmentCreateOrConnectWithoutClaimInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutClaimInput, AttachmentUncheckedCreateWithoutClaimInput>
  }

  export type AttachmentCreateManyClaimInputEnvelope = {
    data: AttachmentCreateManyClaimInput | AttachmentCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type CPMFormCreateWithoutClaimInput = {
    accidentDate: Date | string
    accidentTime: string
    location: string
    cause: string
    repairShop?: string | null
    repairShopLocation?: string | null
    policeDate?: Date | string | null
    policeTime?: string | null
    policeStation?: string | null
    damageOwnType: string
    damageOtherOwn?: string | null
    damageDetail?: string | null
    damageAmount?: number | null
    victimDetail?: string | null
    partnerName?: string | null
    partnerPhone?: string | null
    partnerLocation?: string | null
    partnerDamageDetail?: string | null
    partnerDamageAmount?: number | null
    partnerVictimDetail?: string | null
    phoneNum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CPMFormUncheckedCreateWithoutClaimInput = {
    accidentDate: Date | string
    accidentTime: string
    location: string
    cause: string
    repairShop?: string | null
    repairShopLocation?: string | null
    policeDate?: Date | string | null
    policeTime?: string | null
    policeStation?: string | null
    damageOwnType: string
    damageOtherOwn?: string | null
    damageDetail?: string | null
    damageAmount?: number | null
    victimDetail?: string | null
    partnerName?: string | null
    partnerPhone?: string | null
    partnerLocation?: string | null
    partnerDamageDetail?: string | null
    partnerDamageAmount?: number | null
    partnerVictimDetail?: string | null
    phoneNum?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CPMFormCreateOrConnectWithoutClaimInput = {
    where: CPMFormWhereUniqueInput
    create: XOR<CPMFormCreateWithoutClaimInput, CPMFormUncheckedCreateWithoutClaimInput>
  }

  export type Fppa04BaseCreateWithoutClaimInput = {
    id?: string
    mainType: string
    subType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmVariant?: Fppa04CPMCreateNestedOneWithoutBaseInput
  }

  export type Fppa04BaseUncheckedCreateWithoutClaimInput = {
    id?: string
    mainType: string
    subType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmVariant?: Fppa04CPMUncheckedCreateNestedOneWithoutBaseInput
  }

  export type Fppa04BaseCreateOrConnectWithoutClaimInput = {
    where: Fppa04BaseWhereUniqueInput
    create: XOR<Fppa04BaseCreateWithoutClaimInput, Fppa04BaseUncheckedCreateWithoutClaimInput>
  }

  export type ClaimHistoryCreateWithoutClaimInput = {
    id?: string
    status: $Enums.ClaimStatus
    createdAt?: Date | string
  }

  export type ClaimHistoryUncheckedCreateWithoutClaimInput = {
    id?: string
    status: $Enums.ClaimStatus
    createdAt?: Date | string
  }

  export type ClaimHistoryCreateOrConnectWithoutClaimInput = {
    where: ClaimHistoryWhereUniqueInput
    create: XOR<ClaimHistoryCreateWithoutClaimInput, ClaimHistoryUncheckedCreateWithoutClaimInput>
  }

  export type ClaimHistoryCreateManyClaimInputEnvelope = {
    data: ClaimHistoryCreateManyClaimInput | ClaimHistoryCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClaimsCreatedInput = {
    update: XOR<UserUpdateWithoutClaimsCreatedInput, UserUncheckedUpdateWithoutClaimsCreatedInput>
    create: XOR<UserCreateWithoutClaimsCreatedInput, UserUncheckedCreateWithoutClaimsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaimsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaimsCreatedInput, UserUncheckedUpdateWithoutClaimsCreatedInput>
  }

  export type UserUpdateWithoutClaimsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutClaimsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    employeeNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpsertWithWhereUniqueWithoutClaimInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutClaimInput, AttachmentUncheckedUpdateWithoutClaimInput>
    create: XOR<AttachmentCreateWithoutClaimInput, AttachmentUncheckedCreateWithoutClaimInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutClaimInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutClaimInput, AttachmentUncheckedUpdateWithoutClaimInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutClaimInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutClaimInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    claimId?: StringFilter<"Attachment"> | string
    type?: EnumAttachmentTypeFilter<"Attachment"> | $Enums.AttachmentType
    fileName?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    uploadedAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type CPMFormUpsertWithoutClaimInput = {
    update: XOR<CPMFormUpdateWithoutClaimInput, CPMFormUncheckedUpdateWithoutClaimInput>
    create: XOR<CPMFormCreateWithoutClaimInput, CPMFormUncheckedCreateWithoutClaimInput>
    where?: CPMFormWhereInput
  }

  export type CPMFormUpdateToOneWithWhereWithoutClaimInput = {
    where?: CPMFormWhereInput
    data: XOR<CPMFormUpdateWithoutClaimInput, CPMFormUncheckedUpdateWithoutClaimInput>
  }

  export type CPMFormUpdateWithoutClaimInput = {
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accidentTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    repairShop?: NullableStringFieldUpdateOperationsInput | string | null
    repairShopLocation?: NullableStringFieldUpdateOperationsInput | string | null
    policeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policeTime?: NullableStringFieldUpdateOperationsInput | string | null
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null
    damageOwnType?: StringFieldUpdateOperationsInput | string
    damageOtherOwn?: NullableStringFieldUpdateOperationsInput | string | null
    damageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    victimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerName?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    partnerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    partnerVictimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CPMFormUncheckedUpdateWithoutClaimInput = {
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    accidentTime?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    cause?: StringFieldUpdateOperationsInput | string
    repairShop?: NullableStringFieldUpdateOperationsInput | string | null
    repairShopLocation?: NullableStringFieldUpdateOperationsInput | string | null
    policeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    policeTime?: NullableStringFieldUpdateOperationsInput | string | null
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null
    damageOwnType?: StringFieldUpdateOperationsInput | string
    damageOtherOwn?: NullableStringFieldUpdateOperationsInput | string | null
    damageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    victimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerName?: NullableStringFieldUpdateOperationsInput | string | null
    partnerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    partnerLocation?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageDetail?: NullableStringFieldUpdateOperationsInput | string | null
    partnerDamageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    partnerVictimDetail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Fppa04BaseUpsertWithoutClaimInput = {
    update: XOR<Fppa04BaseUpdateWithoutClaimInput, Fppa04BaseUncheckedUpdateWithoutClaimInput>
    create: XOR<Fppa04BaseCreateWithoutClaimInput, Fppa04BaseUncheckedCreateWithoutClaimInput>
    where?: Fppa04BaseWhereInput
  }

  export type Fppa04BaseUpdateToOneWithWhereWithoutClaimInput = {
    where?: Fppa04BaseWhereInput
    data: XOR<Fppa04BaseUpdateWithoutClaimInput, Fppa04BaseUncheckedUpdateWithoutClaimInput>
  }

  export type Fppa04BaseUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    mainType?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmVariant?: Fppa04CPMUpdateOneWithoutBaseNestedInput
  }

  export type Fppa04BaseUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    mainType?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmVariant?: Fppa04CPMUncheckedUpdateOneWithoutBaseNestedInput
  }

  export type ClaimHistoryUpsertWithWhereUniqueWithoutClaimInput = {
    where: ClaimHistoryWhereUniqueInput
    update: XOR<ClaimHistoryUpdateWithoutClaimInput, ClaimHistoryUncheckedUpdateWithoutClaimInput>
    create: XOR<ClaimHistoryCreateWithoutClaimInput, ClaimHistoryUncheckedCreateWithoutClaimInput>
  }

  export type ClaimHistoryUpdateWithWhereUniqueWithoutClaimInput = {
    where: ClaimHistoryWhereUniqueInput
    data: XOR<ClaimHistoryUpdateWithoutClaimInput, ClaimHistoryUncheckedUpdateWithoutClaimInput>
  }

  export type ClaimHistoryUpdateManyWithWhereWithoutClaimInput = {
    where: ClaimHistoryScalarWhereInput
    data: XOR<ClaimHistoryUpdateManyMutationInput, ClaimHistoryUncheckedUpdateManyWithoutClaimInput>
  }

  export type ClaimHistoryScalarWhereInput = {
    AND?: ClaimHistoryScalarWhereInput | ClaimHistoryScalarWhereInput[]
    OR?: ClaimHistoryScalarWhereInput[]
    NOT?: ClaimHistoryScalarWhereInput | ClaimHistoryScalarWhereInput[]
    id?: StringFilter<"ClaimHistory"> | string
    claimId?: StringFilter<"ClaimHistory"> | string
    status?: EnumClaimStatusFilter<"ClaimHistory"> | $Enums.ClaimStatus
    createdAt?: DateTimeFilter<"ClaimHistory"> | Date | string
  }

  export type ClaimCreateWithoutAttachmentsInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutClaimsCreatedInput
    cpmForm?: CPMFormCreateNestedOneWithoutClaimInput
    fppa04Base?: Fppa04BaseCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    createdById: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cpmForm?: CPMFormUncheckedCreateNestedOneWithoutClaimInput
    fppa04Base?: Fppa04BaseUncheckedCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutAttachmentsInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutAttachmentsInput, ClaimUncheckedCreateWithoutAttachmentsInput>
  }

  export type ClaimUpsertWithoutAttachmentsInput = {
    update: XOR<ClaimUpdateWithoutAttachmentsInput, ClaimUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<ClaimCreateWithoutAttachmentsInput, ClaimUncheckedCreateWithoutAttachmentsInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutAttachmentsInput, ClaimUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ClaimUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutClaimsCreatedNestedInput
    cpmForm?: CPMFormUpdateOneWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cpmForm?: CPMFormUncheckedUpdateOneWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUncheckedUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateWithoutCpmFormInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutClaimsCreatedInput
    attachments?: AttachmentCreateNestedManyWithoutClaimInput
    fppa04Base?: Fppa04BaseCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutCpmFormInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    createdById: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutClaimInput
    fppa04Base?: Fppa04BaseUncheckedCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutCpmFormInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutCpmFormInput, ClaimUncheckedCreateWithoutCpmFormInput>
  }

  export type ClaimUpsertWithoutCpmFormInput = {
    update: XOR<ClaimUpdateWithoutCpmFormInput, ClaimUncheckedUpdateWithoutCpmFormInput>
    create: XOR<ClaimCreateWithoutCpmFormInput, ClaimUncheckedCreateWithoutCpmFormInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutCpmFormInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutCpmFormInput, ClaimUncheckedUpdateWithoutCpmFormInput>
  }

  export type ClaimUpdateWithoutCpmFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutClaimsCreatedNestedInput
    attachments?: AttachmentUpdateManyWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutCpmFormInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUncheckedUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateWithoutFppa04BaseInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutClaimsCreatedInput
    attachments?: AttachmentCreateNestedManyWithoutClaimInput
    cpmForm?: CPMFormCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutFppa04BaseInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    createdById: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutClaimInput
    cpmForm?: CPMFormUncheckedCreateNestedOneWithoutClaimInput
    history?: ClaimHistoryUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutFppa04BaseInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutFppa04BaseInput, ClaimUncheckedCreateWithoutFppa04BaseInput>
  }

  export type Fppa04CPMCreateWithoutBaseInput = {
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: Fppa04ItemCPMCreateNestedManyWithoutVariantInput
    adjustments?: Fppa04AdjustmentCPMCreateNestedManyWithoutVariantInput
  }

  export type Fppa04CPMUncheckedCreateWithoutBaseInput = {
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: Fppa04ItemCPMUncheckedCreateNestedManyWithoutVariantInput
    adjustments?: Fppa04AdjustmentCPMUncheckedCreateNestedManyWithoutVariantInput
  }

  export type Fppa04CPMCreateOrConnectWithoutBaseInput = {
    where: Fppa04CPMWhereUniqueInput
    create: XOR<Fppa04CPMCreateWithoutBaseInput, Fppa04CPMUncheckedCreateWithoutBaseInput>
  }

  export type ClaimUpsertWithoutFppa04BaseInput = {
    update: XOR<ClaimUpdateWithoutFppa04BaseInput, ClaimUncheckedUpdateWithoutFppa04BaseInput>
    create: XOR<ClaimCreateWithoutFppa04BaseInput, ClaimUncheckedCreateWithoutFppa04BaseInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutFppa04BaseInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutFppa04BaseInput, ClaimUncheckedUpdateWithoutFppa04BaseInput>
  }

  export type ClaimUpdateWithoutFppa04BaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutClaimsCreatedNestedInput
    attachments?: AttachmentUpdateManyWithoutClaimNestedInput
    cpmForm?: CPMFormUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutFppa04BaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutClaimNestedInput
    cpmForm?: CPMFormUncheckedUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type Fppa04CPMUpsertWithoutBaseInput = {
    update: XOR<Fppa04CPMUpdateWithoutBaseInput, Fppa04CPMUncheckedUpdateWithoutBaseInput>
    create: XOR<Fppa04CPMCreateWithoutBaseInput, Fppa04CPMUncheckedCreateWithoutBaseInput>
    where?: Fppa04CPMWhereInput
  }

  export type Fppa04CPMUpdateToOneWithWhereWithoutBaseInput = {
    where?: Fppa04CPMWhereInput
    data: XOR<Fppa04CPMUpdateWithoutBaseInput, Fppa04CPMUncheckedUpdateWithoutBaseInput>
  }

  export type Fppa04CPMUpdateWithoutBaseInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: Fppa04ItemCPMUpdateManyWithoutVariantNestedInput
    adjustments?: Fppa04AdjustmentCPMUpdateManyWithoutVariantNestedInput
  }

  export type Fppa04CPMUncheckedUpdateWithoutBaseInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: Fppa04ItemCPMUncheckedUpdateManyWithoutVariantNestedInput
    adjustments?: Fppa04AdjustmentCPMUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type Fppa04BaseCreateWithoutCpmVariantInput = {
    id?: string
    mainType: string
    subType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    claim: ClaimCreateNestedOneWithoutFppa04BaseInput
  }

  export type Fppa04BaseUncheckedCreateWithoutCpmVariantInput = {
    id?: string
    claimId: string
    mainType: string
    subType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Fppa04BaseCreateOrConnectWithoutCpmVariantInput = {
    where: Fppa04BaseWhereUniqueInput
    create: XOR<Fppa04BaseCreateWithoutCpmVariantInput, Fppa04BaseUncheckedCreateWithoutCpmVariantInput>
  }

  export type Fppa04ItemCPMCreateWithoutVariantInput = {
    id?: string
    category: string
    description: string
    total: number
    exception: number
  }

  export type Fppa04ItemCPMUncheckedCreateWithoutVariantInput = {
    id?: string
    category: string
    description: string
    total: number
    exception: number
  }

  export type Fppa04ItemCPMCreateOrConnectWithoutVariantInput = {
    where: Fppa04ItemCPMWhereUniqueInput
    create: XOR<Fppa04ItemCPMCreateWithoutVariantInput, Fppa04ItemCPMUncheckedCreateWithoutVariantInput>
  }

  export type Fppa04ItemCPMCreateManyVariantInputEnvelope = {
    data: Fppa04ItemCPMCreateManyVariantInput | Fppa04ItemCPMCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type Fppa04AdjustmentCPMCreateWithoutVariantInput = {
    id?: string
    type: string
    description: string
    amount: number
  }

  export type Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput = {
    id?: string
    type: string
    description: string
    amount: number
  }

  export type Fppa04AdjustmentCPMCreateOrConnectWithoutVariantInput = {
    where: Fppa04AdjustmentCPMWhereUniqueInput
    create: XOR<Fppa04AdjustmentCPMCreateWithoutVariantInput, Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput>
  }

  export type Fppa04AdjustmentCPMCreateManyVariantInputEnvelope = {
    data: Fppa04AdjustmentCPMCreateManyVariantInput | Fppa04AdjustmentCPMCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type Fppa04BaseUpsertWithoutCpmVariantInput = {
    update: XOR<Fppa04BaseUpdateWithoutCpmVariantInput, Fppa04BaseUncheckedUpdateWithoutCpmVariantInput>
    create: XOR<Fppa04BaseCreateWithoutCpmVariantInput, Fppa04BaseUncheckedCreateWithoutCpmVariantInput>
    where?: Fppa04BaseWhereInput
  }

  export type Fppa04BaseUpdateToOneWithWhereWithoutCpmVariantInput = {
    where?: Fppa04BaseWhereInput
    data: XOR<Fppa04BaseUpdateWithoutCpmVariantInput, Fppa04BaseUncheckedUpdateWithoutCpmVariantInput>
  }

  export type Fppa04BaseUpdateWithoutCpmVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    mainType?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUpdateOneRequiredWithoutFppa04BaseNestedInput
  }

  export type Fppa04BaseUncheckedUpdateWithoutCpmVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    mainType?: StringFieldUpdateOperationsInput | string
    subType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Fppa04ItemCPMUpsertWithWhereUniqueWithoutVariantInput = {
    where: Fppa04ItemCPMWhereUniqueInput
    update: XOR<Fppa04ItemCPMUpdateWithoutVariantInput, Fppa04ItemCPMUncheckedUpdateWithoutVariantInput>
    create: XOR<Fppa04ItemCPMCreateWithoutVariantInput, Fppa04ItemCPMUncheckedCreateWithoutVariantInput>
  }

  export type Fppa04ItemCPMUpdateWithWhereUniqueWithoutVariantInput = {
    where: Fppa04ItemCPMWhereUniqueInput
    data: XOR<Fppa04ItemCPMUpdateWithoutVariantInput, Fppa04ItemCPMUncheckedUpdateWithoutVariantInput>
  }

  export type Fppa04ItemCPMUpdateManyWithWhereWithoutVariantInput = {
    where: Fppa04ItemCPMScalarWhereInput
    data: XOR<Fppa04ItemCPMUpdateManyMutationInput, Fppa04ItemCPMUncheckedUpdateManyWithoutVariantInput>
  }

  export type Fppa04ItemCPMScalarWhereInput = {
    AND?: Fppa04ItemCPMScalarWhereInput | Fppa04ItemCPMScalarWhereInput[]
    OR?: Fppa04ItemCPMScalarWhereInput[]
    NOT?: Fppa04ItemCPMScalarWhereInput | Fppa04ItemCPMScalarWhereInput[]
    id?: StringFilter<"Fppa04ItemCPM"> | string
    baseId?: StringFilter<"Fppa04ItemCPM"> | string
    category?: StringFilter<"Fppa04ItemCPM"> | string
    description?: StringFilter<"Fppa04ItemCPM"> | string
    total?: FloatFilter<"Fppa04ItemCPM"> | number
    exception?: FloatFilter<"Fppa04ItemCPM"> | number
  }

  export type Fppa04AdjustmentCPMUpsertWithWhereUniqueWithoutVariantInput = {
    where: Fppa04AdjustmentCPMWhereUniqueInput
    update: XOR<Fppa04AdjustmentCPMUpdateWithoutVariantInput, Fppa04AdjustmentCPMUncheckedUpdateWithoutVariantInput>
    create: XOR<Fppa04AdjustmentCPMCreateWithoutVariantInput, Fppa04AdjustmentCPMUncheckedCreateWithoutVariantInput>
  }

  export type Fppa04AdjustmentCPMUpdateWithWhereUniqueWithoutVariantInput = {
    where: Fppa04AdjustmentCPMWhereUniqueInput
    data: XOR<Fppa04AdjustmentCPMUpdateWithoutVariantInput, Fppa04AdjustmentCPMUncheckedUpdateWithoutVariantInput>
  }

  export type Fppa04AdjustmentCPMUpdateManyWithWhereWithoutVariantInput = {
    where: Fppa04AdjustmentCPMScalarWhereInput
    data: XOR<Fppa04AdjustmentCPMUpdateManyMutationInput, Fppa04AdjustmentCPMUncheckedUpdateManyWithoutVariantInput>
  }

  export type Fppa04AdjustmentCPMScalarWhereInput = {
    AND?: Fppa04AdjustmentCPMScalarWhereInput | Fppa04AdjustmentCPMScalarWhereInput[]
    OR?: Fppa04AdjustmentCPMScalarWhereInput[]
    NOT?: Fppa04AdjustmentCPMScalarWhereInput | Fppa04AdjustmentCPMScalarWhereInput[]
    id?: StringFilter<"Fppa04AdjustmentCPM"> | string
    baseId?: StringFilter<"Fppa04AdjustmentCPM"> | string
    type?: StringFilter<"Fppa04AdjustmentCPM"> | string
    description?: StringFilter<"Fppa04AdjustmentCPM"> | string
    amount?: FloatFilter<"Fppa04AdjustmentCPM"> | number
  }

  export type Fppa04CPMCreateWithoutItemsInput = {
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    base: Fppa04BaseCreateNestedOneWithoutCpmVariantInput
    adjustments?: Fppa04AdjustmentCPMCreateNestedManyWithoutVariantInput
  }

  export type Fppa04CPMUncheckedCreateWithoutItemsInput = {
    baseId: string
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    adjustments?: Fppa04AdjustmentCPMUncheckedCreateNestedManyWithoutVariantInput
  }

  export type Fppa04CPMCreateOrConnectWithoutItemsInput = {
    where: Fppa04CPMWhereUniqueInput
    create: XOR<Fppa04CPMCreateWithoutItemsInput, Fppa04CPMUncheckedCreateWithoutItemsInput>
  }

  export type Fppa04CPMUpsertWithoutItemsInput = {
    update: XOR<Fppa04CPMUpdateWithoutItemsInput, Fppa04CPMUncheckedUpdateWithoutItemsInput>
    create: XOR<Fppa04CPMCreateWithoutItemsInput, Fppa04CPMUncheckedCreateWithoutItemsInput>
    where?: Fppa04CPMWhereInput
  }

  export type Fppa04CPMUpdateToOneWithWhereWithoutItemsInput = {
    where?: Fppa04CPMWhereInput
    data: XOR<Fppa04CPMUpdateWithoutItemsInput, Fppa04CPMUncheckedUpdateWithoutItemsInput>
  }

  export type Fppa04CPMUpdateWithoutItemsInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    base?: Fppa04BaseUpdateOneRequiredWithoutCpmVariantNestedInput
    adjustments?: Fppa04AdjustmentCPMUpdateManyWithoutVariantNestedInput
  }

  export type Fppa04CPMUncheckedUpdateWithoutItemsInput = {
    baseId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustments?: Fppa04AdjustmentCPMUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type Fppa04CPMCreateWithoutAdjustmentsInput = {
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    base: Fppa04BaseCreateNestedOneWithoutCpmVariantInput
    items?: Fppa04ItemCPMCreateNestedManyWithoutVariantInput
  }

  export type Fppa04CPMUncheckedCreateWithoutAdjustmentsInput = {
    baseId: string
    eventType: string
    claimRefNumber: string
    eventDescription: string
    productionYear: number
    accidentDate: Date | string
    reportedDate: Date | string
    receivedDocDate: Date | string
    company: string
    factory: string
    policyNumber: string
    surveyorRefNumber: string
    insurancePayout: number
    netAmount: number
    signatureFiles?: Fppa04CPMCreatesignatureFilesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: Fppa04ItemCPMUncheckedCreateNestedManyWithoutVariantInput
  }

  export type Fppa04CPMCreateOrConnectWithoutAdjustmentsInput = {
    where: Fppa04CPMWhereUniqueInput
    create: XOR<Fppa04CPMCreateWithoutAdjustmentsInput, Fppa04CPMUncheckedCreateWithoutAdjustmentsInput>
  }

  export type Fppa04CPMUpsertWithoutAdjustmentsInput = {
    update: XOR<Fppa04CPMUpdateWithoutAdjustmentsInput, Fppa04CPMUncheckedUpdateWithoutAdjustmentsInput>
    create: XOR<Fppa04CPMCreateWithoutAdjustmentsInput, Fppa04CPMUncheckedCreateWithoutAdjustmentsInput>
    where?: Fppa04CPMWhereInput
  }

  export type Fppa04CPMUpdateToOneWithWhereWithoutAdjustmentsInput = {
    where?: Fppa04CPMWhereInput
    data: XOR<Fppa04CPMUpdateWithoutAdjustmentsInput, Fppa04CPMUncheckedUpdateWithoutAdjustmentsInput>
  }

  export type Fppa04CPMUpdateWithoutAdjustmentsInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    base?: Fppa04BaseUpdateOneRequiredWithoutCpmVariantNestedInput
    items?: Fppa04ItemCPMUpdateManyWithoutVariantNestedInput
  }

  export type Fppa04CPMUncheckedUpdateWithoutAdjustmentsInput = {
    baseId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    claimRefNumber?: StringFieldUpdateOperationsInput | string
    eventDescription?: StringFieldUpdateOperationsInput | string
    productionYear?: IntFieldUpdateOperationsInput | number
    accidentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receivedDocDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    factory?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    surveyorRefNumber?: StringFieldUpdateOperationsInput | string
    insurancePayout?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    signatureFiles?: Fppa04CPMUpdatesignatureFilesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: Fppa04ItemCPMUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ClaimCreateWithoutHistoryInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutClaimsCreatedInput
    attachments?: AttachmentCreateNestedManyWithoutClaimInput
    cpmForm?: CPMFormCreateNestedOneWithoutClaimInput
    fppa04Base?: Fppa04BaseCreateNestedOneWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutHistoryInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    createdById: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutClaimInput
    cpmForm?: CPMFormUncheckedCreateNestedOneWithoutClaimInput
    fppa04Base?: Fppa04BaseUncheckedCreateNestedOneWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutHistoryInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutHistoryInput, ClaimUncheckedCreateWithoutHistoryInput>
  }

  export type ClaimUpsertWithoutHistoryInput = {
    update: XOR<ClaimUpdateWithoutHistoryInput, ClaimUncheckedUpdateWithoutHistoryInput>
    create: XOR<ClaimCreateWithoutHistoryInput, ClaimUncheckedCreateWithoutHistoryInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutHistoryInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutHistoryInput, ClaimUncheckedUpdateWithoutHistoryInput>
  }

  export type ClaimUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutClaimsCreatedNestedInput
    attachments?: AttachmentUpdateManyWithoutClaimNestedInput
    cpmForm?: CPMFormUpdateOneWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUpdateOneWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutClaimNestedInput
    cpmForm?: CPMFormUncheckedUpdateOneWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUncheckedUpdateOneWithoutClaimNestedInput
  }

  export type ClaimCreateManyCreatedByInput = {
    id?: string
    docNum: string
    createdByName: string
    approverName: string
    approverPosition: string
    approverDepartment: string
    approverEmail: string
    approverId: string
    signerId?: string | null
    signerEmail?: string | null
    signerName?: string | null
    signerPosition?: string | null
    status?: $Enums.ClaimStatus
    categoryMain?: string | null
    categorySub?: string | null
    submittedAt?: Date | string | null
    insurerComment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutClaimNestedInput
    cpmForm?: CPMFormUpdateOneWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutClaimNestedInput
    cpmForm?: CPMFormUncheckedUpdateOneWithoutClaimNestedInput
    fppa04Base?: Fppa04BaseUncheckedUpdateOneWithoutClaimNestedInput
    history?: ClaimHistoryUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    docNum?: StringFieldUpdateOperationsInput | string
    createdByName?: StringFieldUpdateOperationsInput | string
    approverName?: StringFieldUpdateOperationsInput | string
    approverPosition?: StringFieldUpdateOperationsInput | string
    approverDepartment?: StringFieldUpdateOperationsInput | string
    approverEmail?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    signerId?: NullableStringFieldUpdateOperationsInput | string | null
    signerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    signerName?: NullableStringFieldUpdateOperationsInput | string | null
    signerPosition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    categoryMain?: NullableStringFieldUpdateOperationsInput | string | null
    categorySub?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insurerComment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyClaimInput = {
    id?: string
    type: $Enums.AttachmentType
    fileName: string
    url: string
    uploadedAt?: Date | string
  }

  export type ClaimHistoryCreateManyClaimInput = {
    id?: string
    status: $Enums.ClaimStatus
    createdAt?: Date | string
  }

  export type AttachmentUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAttachmentTypeFieldUpdateOperationsInput | $Enums.AttachmentType
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimHistoryUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimHistoryUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimHistoryUncheckedUpdateManyWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Fppa04ItemCPMCreateManyVariantInput = {
    id?: string
    category: string
    description: string
    total: number
    exception: number
  }

  export type Fppa04AdjustmentCPMCreateManyVariantInput = {
    id?: string
    type: string
    description: string
    amount: number
  }

  export type Fppa04ItemCPMUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    exception?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04ItemCPMUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    exception?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04ItemCPMUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    total?: FloatFieldUpdateOperationsInput | number
    exception?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04AdjustmentCPMUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04AdjustmentCPMUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type Fppa04AdjustmentCPMUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}